<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Master RPS AI v2.0 | Doulet Media</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
            background-color: #f5f7fa;
            color: #2c3e50;
        }
        h1 {
            color: #3498db;
            margin-bottom: 5px;
        }
        .subtitle {
            color: #7f8c8d;
            margin-bottom: 30px;
        }
        .choices {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 40px 0;
            flex-wrap: wrap;
        }
        .choice {
            font-size: 70px;
            cursor: pointer;
            padding: 15px;
            border-radius: 15px;
            transition: all 0.3s;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .choice:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
        }
        #result {
            font-size: 26px;
            margin: 30px 0;
            min-height: 120px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .stats-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
            margin: 30px 0;
        }
        .stat-box {
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            min-width: 150px;
        }
        .analysis {
            margin-top: 40px;
            padding: 20px;
            background-color: #2c3e50;
            color: white;
            border-radius: 10px;
            text-align: left;
        }
        .strategy-tag {
            display: inline-block;
            padding: 3px 8px;
            background-color: #e74c3c;
            color: white;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        #confidence-meter {
            height: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        #confidence-level {
            height: 100%;
            background-color: #2ecc71;
            width: 0%;
            transition: width 0.5s;
        }
        .advanced-stats {
            margin-top: 20px;
            padding: 15px;
            background-color: #34495e;
            color: white;
            border-radius: 10px;
        }
        .pattern-vis {
            font-family: monospace;
            font-size: 18px;
            letter-spacing: 3px;
        }
        .footer {
            margin-top: 30px;
            color: #7f8c8d;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>Master RPS AI v2.0</h1>
    <p class="subtitle">Developed by Doulet Media | Now with guaranteed valid moves</p>
    
    <div class="choices">
        <div class="choice" data-choice="rock">✊</div>
        <div class="choice" data-choice="paper">✋</div>
        <div class="choice" data-choice="scissors">✌️</div>
    </div>
    
    <div id="result">Make your move!</div>
    
    <div class="stats-container">
        <div class="stat-box">
            <h3>Games Played</h3>
            <p id="games-played">0</p>
        </div>
        <div class="stat-box">
            <h3>Your Wins</h3>
            <p id="user-wins">0</p>
        </div>
        <div class="stat-box">
            <h3>AI Wins</h3>
            <p id="bot-wins">0</p>
        </div>
        <div class="stat-box">
            <h3>Win Rate</h3>
            <p id="win-rate">0%</p>
        </div>
    </div>
    
    <div class="analysis">
        <h2>AI Analysis</h2>
        <div id="pattern-info">Collecting initial data...</div>
        <div id="confidence">
            <div>Prediction Confidence: <span id="confidence-value">0</span>%</div>
            <div id="confidence-meter">
                <div id="confidence-level"></div>
            </div>
        </div>
        <div id="strategy-tags"></div>
    </div>
    
    <div class="advanced-stats">
        <h3>Advanced Statistics</h3>
        <div id="repetition-score">Repetition detection: 0%</div>
        <div id="pattern-cycle">Pattern cycle: None detected</div>
        <div class="pattern-vis" id="pattern-vis"></div>
        <div id="player-type">Player type: Unknown</div>
    </div>
    
    <div class="footer">
        <p>© 2024 Doulet Media | This AI learns your patterns to maximize wins—with no undefined moves!</p>
    </div>
    
    <script>
        // Game state with advanced tracking
        const state = {
            gamesPlayed: 0,
            userWins: 0,
            botWins: 0,
            ties: 0,
            history: [],
            moveCounts: { rock: 0, paper: 0, scissors: 0 },
            
            // Multi-order Markov chains
            transitions: {
                order1: {
                    rock: { rock: 0, paper: 0, scissors: 0 },
                    paper: { rock: 0, paper: 0, scissors: 0 },
                    scissors: { rock: 0, paper: 0, scissors: 0 }
                },
                order2: {}
            },
            
            // Repetition tracking
            repetitionCounters: { rock: 0, paper: 0, scissors: 0 },
            lastFiveMoves: [],
            consecutiveRepeats: 0,
            
            // Player typing
            playerType: null,
            detectedStrategies: new Set(),
            strategyHistory: [],
            
            // Anti-pattern measures
            antiPatternMode: false,
            lastBotMove: null,
            streak: 0,
            lastStreakMove: null,
            
            // Confidence tracking
            confidence: 0
        };

        // Initialize all order2 transitions
        const moves = ['rock', 'paper', 'scissors'];
        moves.forEach(move1 => {
            moves.forEach(move2 => {
                state.transitions.order2[`${move1}-${move2}`] = { rock: 0, paper: 0, scissors: 0 };
            });
        });

        // Move relationships
        const beats = {
            rock: 'scissors',
            paper: 'rock',
            scissors: 'paper'
        };
        
        const moveToEmoji = {
            rock: '✊',
            paper: '✋',
            scissors: '✌️'
        };
        
        const moveNames = {
            rock: 'Rock',
            paper: 'Paper',
            scissors: 'Scissors'
        };
        
        // Known player strategies
        const STRATEGIES = {
            WIN_STAY: 'win-stay/lose-shift',
            GAMBLERS_FALLACY: 'gambler\'s fallacy',
            COUNTER_BOT: 'countering bot patterns',
            RANDOM: 'pseudo-random',
            FREQUENCY_BIAS: 'frequency bias',
            REPEAT_AVOIDANCE: 'repeat avoidance',
            SPAMMER: 'move spammer'
        };

        // Player type thresholds
        const PLAYER_TYPES = {
            RANDOM: { name: "Random", threshold: 0.1 },
            SPAMMER: { name: "Spammer", threshold: 0.9 },
            CYCLIC: { name: "Cyclic", threshold: 0.7 },
            COUNTER: { name: "Counter-Player", threshold: 0.6 },
            NORMAL: { name: "Normal", threshold: 0.4 }
        };

        // DOM elements
        const resultEl = document.getElementById('result');
        const patternInfoEl = document.getElementById('pattern-info');
        const confidenceValueEl = document.getElementById('confidence-value');
        const confidenceLevelEl = document.getElementById('confidence-level');
        const strategyTagsEl = document.getElementById('strategy-tags');
        const repetitionScoreEl = document.getElementById('repetition-score');
        const patternCycleEl = document.getElementById('pattern-cycle');
        const patternVisEl = document.getElementById('pattern-vis');
        const playerTypeEl = document.getElementById('player-type');
        
        // Event listeners
        document.querySelectorAll('.choice').forEach(choice => {
            choice.addEventListener('click', (e) => {
                const userChoice = e.target.getAttribute('data-choice');
                playGame(userChoice);
            });
        });

        function playGame(userChoice) {
            state.gamesPlayed++;
            state.moveCounts[userChoice]++;
            
            // Update transition matrices
            updateTransitions(userChoice);
            
            // Update repetition tracking
            updateRepetitionCounters(userChoice);
            
            // Detect player type and strategies
            detectPlayerType();
            detectStrategies(userChoice);
            
            // Bot makes its choice using advanced decision making
            const { botChoice, confidence, strategy } = makeAdvancedDecision();
            state.confidence = confidence;
            
            // Determine winner
            let result;
            if (userChoice === botChoice) {
                result = 'tie';
                state.ties++;
            } else if (beats[userChoice] === botChoice) {
                result = 'user';
                state.userWins++;
            } else {
                result = 'bot';
                state.botWins++;
            }
            
            // Update game state
            state.history.push(userChoice);
            state.lastBotMove = botChoice;
            updateStreak(result);
            
            // Update UI
            updateUI(userChoice, botChoice, result, strategy);
        }
        
        function updateTransitions(userChoice) {
            // Update order1 transitions
            if (state.history.length > 0) {
                const lastMove = state.history[state.history.length - 1];
                state.transitions.order1[lastMove][userChoice]++;
            }
            
            // Update order2 transitions
            if (state.history.length > 1) {
                const lastTwo = state.history.slice(-2);
                const key = `${lastTwo[0]}-${lastTwo[1]}`;
                state.transitions.order2[key][userChoice]++;
            }
        }
        
        function updateRepetitionCounters(userChoice) {
            // Track last 5 moves
            state.lastFiveMoves.push(userChoice);
            if (state.lastFiveMoves.length > 5) {
                state.lastFiveMoves.shift();
            }
            
            // Increase counter for the chosen move
            state.repetitionCounters[userChoice]++;
            
            // Decay other counters (forgetting factor)
            for (const move in state.repetitionCounters) {
                if (move !== userChoice) {
                    state.repetitionCounters[move] *= 0.7; // Strong decay for spammers
                }
            }
            
            // Check for consecutive repeats
            if (state.history.length > 0 && 
                state.history[state.history.length - 1] === userChoice) {
                state.consecutiveRepeats++;
            } else {
                state.consecutiveRepeats = 0;
            }
        }
        
        function detectPlayerType() {
            if (state.gamesPlayed < 3) return;
            
            // Calculate repetition score
            const totalMoves = state.gamesPlayed;
            const maxRepetition = Math.max(...Object.values(state.repetitionCounters));
            const repetitionScore = maxRepetition / totalMoves;
            
            // Check for cyclic patterns
            const cycle = detectCycle();
            
            // Determine player type
            if (repetitionScore > PLAYER_TYPES.SPAMMER.threshold) {
                state.playerType = PLAYER_TYPES.SPAMMER;
                state.detectedStrategies.add(STRATEGIES.SPAMMER);
            } 
            else if (cycle && state.gamesPlayed > 10) {
                state.playerType = PLAYER_TYPES.CYCLIC;
                state.patternCycle = cycle;
            }
            else if (repetitionScore < PLAYER_TYPES.RANDOM.threshold) {
                state.playerType = PLAYER_TYPES.RANDOM;
            }
            else {
                state.playerType = PLAYER_TYPES.NORMAL;
            }
            
            // Check if player is trying to counter our patterns
            if (state.gamesPlayed > 15) {
                const counterScore = calculateCounterScore();
                if (counterScore > PLAYER_TYPES.COUNTER.threshold) {
                    state.playerType = PLAYER_TYPES.COUNTER;
                    state.antiPatternMode = true;
                    state.detectedStrategies.add(STRATEGIES.COUNTER_BOT);
                }
            }
            
            updatePlayerTypeUI();
        }
        
        function detectCycle() {
            if (state.history.length < 6) return null;
            
            // Look for cycles of length 2-5
            for (let cycleLength = 2; cycleLength <= 5; cycleLength++) {
                if (state.history.length < cycleLength * 2) continue;
                
                const recent = state.history.slice(-cycleLength);
                const previous = state.history.slice(-cycleLength * 2, -cycleLength);
                
                if (JSON.stringify(recent) === JSON.stringify(previous)) {
                    return recent;
                }
            }
            return null;
        }
        
        function calculateCounterScore() {
            // Measures how often player beats our last move
            let counterMoves = 0;
            for (let i = 1; i < state.history.length; i++) {
                if (beats[state.history[i]] === state.history[i-1]) {
                    counterMoves++;
                }
            }
            return counterMoves / (state.history.length - 1);
        }
        
        function detectStrategies(userChoice) {
            // Detect win-stay/lose-shift
            if (state.history.length >= 3) {
                const lastGameResult = getGameResult(state.history.length - 2);
                const lastMove = state.history[state.history.length - 2];
                const currentMove = state.history[state.history.length - 1];
                
                if (lastGameResult === 'user' && lastMove === currentMove) {
                    state.strategyHistory.push(STRATEGIES.WIN_STAY);
                } else if (lastGameResult === 'bot' && lastMove !== currentMove) {
                    state.strategyHistory.push(STRATEGIES.WIN_STAY);
                }
            }
            
            // Detect repeat avoidance
            if (state.history.length >= 4) {
                const uniqueLastThree = new Set(state.history.slice(-3));
                if (uniqueLastThree.size === 3) {
                    state.strategyHistory.push(STRATEGIES.REPEAT_AVOIDANCE);
                }
            }
            
            // Detect gambler's fallacy
            if (state.history.length >= 5) {
                const recentMoves = state.history.slice(-5);
                const missingMoves = moves.filter(m => !recentMoves.includes(m));
                if (missingMoves.length === 1 && !missingMoves.includes(userChoice)) {
                    state.strategyHistory.push(STRATEGIES.GAMBLERS_FALLACY);
                }
            }
            
            // Update detected strategies based on frequency
            const strategyCounts = {};
            state.strategyHistory.forEach(strategy => {
                strategyCounts[strategy] = (strategyCounts[strategy] || 0) + 1;
            });
            
            for (const [strategy, count] of Object.entries(strategyCounts)) {
                if (count / state.strategyHistory.length > 0.3) {
                    state.detectedStrategies.add(strategy);
                }
            }
        }
        
        function getGameResult(index) {
            if (index <= 0 || index >= state.history.length) return null;
            
            const userMove = state.history[index];
            const botMove = state.history[index - 1]; // Note: Adjust in real implementation
            
            if (userMove === botMove) return 'tie';
            return beats[userMove] === botMove ? 'user' : 'bot';
        }
        
        function makeAdvancedDecision() {
            // Initialize with a random move as fallback
            let botChoice = randomMove();
            let confidence = 0.3;
            let strategy = "Initial random move";
            
            // Only try pattern recognition after 3 moves
            if (state.gamesPlayed >= 3) {
                // Handle move spammers first (e.g., 1000x scissors)
                if (state.consecutiveRepeats >= 2) {
                    const spamMove = state.lastFiveMoves[state.lastFiveMoves.length - 1];
                    if (spamMove) { // Ensure spamMove is defined
                        botChoice = beats[spamMove];
                        confidence = 0.98;
                        strategy = "Countering move spam";
                    }
                }
                
                // Handle cyclic patterns if detected
                else if (state.patternCycle) {
                    const nextInCycle = predictNextInCycle();
                    if (nextInCycle) {
                        botChoice = beats[nextInCycle];
                        confidence = 0.9;
                        strategy = "Countering cyclic pattern";
                    }
                }
                
                // Try other prediction methods if no spam/cycle detected
                else {
                    const predictions = [];
                    
                    // Second-order Markov prediction
                    if (state.history.length >= 2) {
                        const lastTwo = state.history.slice(-2);
                        const key = `${lastTwo[0]}-${lastTwo[1]}`;
                        const prediction = predictFromTransitions(state.transitions.order2[key]);
                        if (prediction.move && prediction.confidence > 0.6) {
                            predictions.push({
                                move: beats[prediction.move],
                                confidence: prediction.confidence,
                                strategy: 'Second-order pattern recognition'
                            });
                        }
                    }
                    
                    // First-order Markov prediction
                    const lastMove = state.history[state.history.length - 1];
                    const prediction1 = predictFromTransitions(state.transitions.order1[lastMove]);
                    if (prediction1.move && prediction1.confidence > 0.55) {
                        predictions.push({
                            move: beats[prediction1.move],
                            confidence: prediction1.confidence,
                            strategy: 'First-order pattern recognition'
                        });
                    }
                    
                    // Select the best prediction if any exist
                    if (predictions.length > 0) {
                        predictions.sort((a, b) => b.confidence - a.confidence);
                        const bestPrediction = predictions[0];
                        
                        // Only override if we have a valid move
                        if (bestPrediction.move) {
                            botChoice = bestPrediction.move;
                            confidence = bestPrediction.confidence;
                            strategy = bestPrediction.strategy;
                        }
                    }
                }
            }
            
            // Final validation to ensure we never return undefined
            if (!botChoice || !['rock', 'paper', 'scissors'].includes(botChoice)) {
                botChoice = randomMove();
                confidence = 0.3;
                strategy = "Fallback random move";
            }
            
            return {
                botChoice: botChoice,
                confidence: confidence,
                strategy: strategy
            };
        }
        
        function predictFromTransitions(transitionCounts) {
            const total = Object.values(transitionCounts).reduce((a, b) => a + b, 0);
            if (total === 0) return { move: randomMove(), confidence: 0 };
            
            let maxCount = -1;
            let predicted = randomMove(); // Default to random
            
            for (const [move, count] of Object.entries(transitionCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    predicted = move;
                }
            }
            
            const confidence = maxCount / total;
            return { move: predicted, confidence };
        }
        
        function predictNextInCycle() {
            if (!state.patternCycle) return null;
            
            const cyclePos = state.history.length % state.patternCycle.length;
            return state.patternCycle[cyclePos];
        }
        
        function counterMostCommonMove() {
            const maxMove = Object.entries(state.moveCounts).reduce(
                (max, [move, count]) => count > max.count ? { move, count } : max,
                { move: null, count: -1 }
            ).move;
            
            return maxMove ? beats[maxMove] : randomMove();
        }
        
        function randomMove() {
            return moves[Math.floor(Math.random() * moves.length)];
        }
        
        function updateStreak(result) {
            if (result === 'bot') {
                if (state.streak >= 0) {
                    state.streak++;
                } else {
                    state.streak = 1;
                }
                state.lastStreakMove = state.lastBotMove;
            } else if (result === 'user') {
                if (state.streak <= 0) {
                    state.streak--;
                } else {
                    state.streak = -1;
                }
            }
        }
        
        function updateUI(userChoice, botChoice, result, strategy) {
            // Update result display
            let resultText = `You chose ${moveToEmoji[userChoice]} ${moveNames[userChoice]}, `;
            resultText += `AI chose ${moveToEmoji[botChoice]} ${moveNames[botChoice]}. `;
            
            switch (result) {
                case 'user':
                    resultText += '<span style="color:#2ecc71;">You win!</span>';
                    break;
                case 'bot':
                    resultText += '<span style="color:#e74c3c;">AI wins!</span>';
                    break;
                case 'tie':
                    resultText += '<span style="color:#3498db;">It\'s a tie!</span>';
                    break;
            }
            
            resultText += `<br><small>AI Strategy: ${strategy}</small>`;
            resultEl.innerHTML = resultText;
            
            // Update stats
            document.getElementById('games-played').textContent = state.gamesPlayed;
            document.getElementById('user-wins').textContent = state.userWins;
            document.getElementById('bot-wins').textContent = state.botWins;
            document.getElementById('win-rate').textContent = 
                ((state.botWins / state.gamesPlayed) * 100).toFixed(1) + '%';
            
            // Update confidence meter
            confidenceValueEl.textContent = Math.round(state.confidence * 100);
            confidenceLevelEl.style.width = `${state.confidence * 100}%`;
            
            // Update pattern info
            updatePatternInfo();
            
            // Update strategy tags
            updateStrategyTags();
        }
        
        function updatePatternInfo() {
            if (state.gamesPlayed < 3) {
                patternInfoEl.textContent = 'Collecting initial data patterns...';
                return;
            }
            
            const analysis = [];
            
            // Frequency analysis
            const total = state.gamesPlayed;
            const rockPct = (state.moveCounts.rock / total * 100).toFixed(1);
            const paperPct = (state.moveCounts.paper / total * 100).toFixed(1);
            const scissorsPct = (state.moveCounts.scissors / total * 100).toFixed(1);
            
            analysis.push(`<strong>Move frequencies:</strong> Rock ${rockPct}%, Paper ${paperPct}%, Scissors ${scissorsPct}%`);
            
            // Recent moves
            if (state.history.length >= 3) {
                const recent = state.history.slice(-3).map(m => moveNames[m]).join(' → ');
                analysis.push(`<strong>Recent sequence:</strong> ${recent}`);
            }
            
            // Transition probabilities
            if (state.history.length >= 2) {
                const lastMove = state.history[state.history.length - 1];
                const transitions = state.transitions.order1[lastMove];
                const totalTransitions = Object.values(transitions).reduce((a, b) => a + b, 0);
                
                if (totalTransitions > 0) {
                    const rockNext = (transitions.rock / totalTransitions * 100).toFixed(1);
                    const paperNext = (transitions.paper / totalTransitions * 100).toFixed(1);
                    const scissorsNext = (transitions.scissors / totalTransitions * 100).toFixed(1);
                    
                    analysis.push(`After ${moveNames[lastMove]}, you usually throw: Rock ${rockNext}%, Paper ${paperNext}%, Scissors ${scissorsNext}%`);
                }
            }
            
            patternInfoEl.innerHTML = analysis.join('<br>');
        }
        
        function updateStrategyTags() {
            if (state.detectedStrategies.size === 0) {
                strategyTagsEl.innerHTML = 'No strong strategy patterns detected yet';
                return;
            }
            
            strategyTagsEl.innerHTML = '<strong>Detected Player Strategies:</strong><br>';
            state.detectedStrategies.forEach(strategy => {
                strategyTagsEl.innerHTML += `<span class="strategy-tag">${strategy}</span>`;
            });
        }
        
        function updatePlayerTypeUI() {
            if (state.playerType) {
                playerTypeEl.textContent = `Player type: ${state.playerType.name}`;
            }
            
            // Calculate repetition percentage
            const maxRepetition = Math.max(...Object.values(state.repetitionCounters));
            const total = Object.values(state.repetitionCounters).reduce((a,b) => a + b, 0);
            const repetitionPct = total > 0 ? (maxRepetition / total * 100).toFixed(1) : 0;
            repetitionScoreEl.textContent = `Repetition detection: ${repetitionPct}%`;
            
            // Display pattern cycle if detected
            if (state.patternCycle) {
                patternCycleEl.textContent = `Pattern cycle: ${state.patternCycle.join(' → ')}`;
                patternVisEl.textContent = `Last moves: ${state.lastFiveMoves.join(' ')}`;
            } else {
                patternCycleEl.textContent = 'Pattern cycle: None detected';
                patternVisEl.textContent = `Last moves: ${state.lastFiveMoves.join(' ')}`;
            }
        }
    </script>
</body>
</html>
