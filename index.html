<!DOCTYPE html>
<html>
<head>
    <title>RPS Deep Learning AI</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .game-container {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }
        .game-area {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .training-panel {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .choices {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        .choices button {
            font-size: 50px;
            width: 80px;
            height: 80px;
            border: none;
            background: #4285f4;
            color: white;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }
        .choices button:hover {
            transform: scale(1.1);
            background: #3367d6;
        }
        .result {
            text-align: center;
            font-size: 24px;
            margin: 20px 0;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }
        .stat-box {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .chart-container {
            position: relative;
            height: 200px;
            margin: 20px 0;
        }
        .model-tabs {
            display: flex;
            margin-bottom: 15px;
        }
        .model-tab {
            padding: 10px 15px;
            cursor: pointer;
            background: #e9ecef;
            border: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }
        .model-tab.active {
            background: #4285f4;
            color: white;
        }
        .model-content {
            display: none;
        }
        .model-content.active {
            display: block;
        }
        #ai-choice {
            font-weight: bold;
        }
        #round-result {
            font-weight: bold;
            color: #1a73e8;
        }
        .loading {
            text-align: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Rock-Paper-Scissors AI</h1>
        <p>Deep Learning AI that learns from your moves and global patterns</p>
    </div>

    <div id="loading" class="loading">
        <p>Loading AI models... Please wait</p>
    </div>

    <div id="game-content" style="display:none;">
        <div class="game-container">
            <div class="game-area">
                <h2>Play Against AI</h2>
                <div class="choices">
                    <button id="rock">✊</button>
                    <button id="paper">✋</button>
                    <button id="scissors">✌️</button>
                </div>
                <div class="result">
                    <p>AI chose: <span id="ai-choice">...</span></p>
                    <p>Result: <span id="round-result">Play a move!</span></p>
                </div>
                <div class="stats">
                    <div class="stat-box">
                        <h3>Your Stats</h3>
                        <p>Games: <span id="user-games">0</span></p>
                        <p>Wins: <span id="user-wins">0</span></p>
                    </div>
                    <div class="stat-box">
                        <h3>AI Stats</h3>
                        <p>Accuracy: <span id="ai-accuracy">0%</span></p>
                        <p>Win Rate: <span id="ai-win-rate">0%</span></p>
                    </div>
                </div>
            </div>

            <div class="training-panel">
                <h2>AI Training Data</h2>
                <div class="model-tabs">
                    <button class="model-tab active" onclick="showModel('user')">Your Model</button>
                    <button class="model-tab" onclick="showModel('global')">Global Model</button>
                </div>
                
                <div id="user-model" class="model-content active">
                    <div class="chart-container">
                        <canvas id="user-loss-chart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="user-accuracy-chart"></canvas>
                    </div>
                    <div class="stats">
                        <div class="stat-box">
                            <p>Training Cycles: <span id="user-cycles">0</span></p>
                        </div>
                        <div class="stat-box">
                            <p>Current Accuracy: <span id="user-current-accuracy">0%</span></p>
                        </div>
                    </div>
                </div>
                
                <div id="global-model" class="model-content">
                    <div class="chart-container">
                        <canvas id="global-loss-chart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="global-accuracy-chart"></canvas>
                    </div>
                    <div class="stats">
                        <div class="stat-box">
                            <p>Training Cycles: <span id="global-cycles">0</span></p>
                        </div>
                        <div class="stat-box">
                            <p>Current Accuracy: <span id="global-current-accuracy">0%</span></p>
                        </div>
                        <div class="stat-box">
                            <p>Total Games: <span id="global-total-games">0</span></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game State
        const gameState = {
            userMoves: [],
            aiMoves: [],
            results: [],
            userWins: 0,
            aiWins: 0,
            draws: 0,
            userModel: null,
            globalModel: null,
            userTrainingHistory: { loss: [], accuracy: [] },
            globalTrainingHistory: { loss: [], accuracy: [] },
            userChartLoss: null,
            userChartAccuracy: null,
            globalChartLoss: null,
            globalChartAccuracy: null,
            modelsReady: false
        };

        // Move encoding
        const MOVES = ['rock', 'paper', 'scissors'];
        const MOVE_EMOJIS = { rock: '✊', paper: '✋', scissors: '✌️' };

        // Initialize when TensorFlow is ready
        async function initialize() {
            // Show loading message
            document.getElementById('loading').textContent = 'Loading AI models... Please wait';
            
            try {
                await tf.ready();
                
                // Create models
                gameState.userModel = createModel();
                gameState.globalModel = createModel();
                
                // Try to load from localStorage
                await loadModels();
                
                // Initialize charts
                initCharts();
                
                // Set up event listeners
                document.getElementById('rock').addEventListener('click', () => playRound('rock'));
                document.getElementById('paper').addEventListener('click', () => playRound('paper'));
                document.getElementById('scissors').addEventListener('click', () => playRound('scissors'));
                
                // Mark models as ready
                gameState.modelsReady = true;
                
                // Hide loading and show game
                document.getElementById('loading').style.display = 'none';
                document.getElementById('game-content').style.display = 'block';
                
                console.log('Game initialized');
            } catch (error) {
                document.getElementById('loading').innerHTML = `
                    <p>Error loading AI models. Please refresh the page.</p>
                    <p>${error.message}</p>
                `;
                console.error('Initialization error:', error);
            }
        }

        // Create neural network model
        function createModel() {
            const model = tf.sequential();
            model.add(tf.layers.dense({
                units: 16,  // Reduced for faster training
                activation: 'relu',
                inputShape: [10]
            }));
            model.add(tf.layers.dense({ units: 8, activation: 'relu' }));
            model.add(tf.layers.dense({ units: 3, activation: 'softmax' }));
            
            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            return model;
        }

        // Play a round of RPS
        async function playRound(userMove) {
            if (!gameState.modelsReady) {
                alert("AI models are still loading. Please wait a moment.");
                return;
            }
            
            // Get AI move (start with random if no history)
            let aiMove;
            if (gameState.userMoves.length < 3) {
                aiMove = MOVES[Math.floor(Math.random() * 3)];
            } else {
                const aiPrediction = await predictAiMove(userMove);
                aiMove = MOVES[aiPrediction];
            }
            
            // Determine winner
            const result = determineWinner(userMove, aiMove);
            
            // Update game state
            gameState.userMoves.push(userMove);
            gameState.aiMoves.push(aiMove);
            gameState.results.push(result);
            
            if (result === 'win') gameState.userWins++;
            if (result === 'lose') gameState.aiWins++;
            if (result === 'draw') gameState.draws++;
            
            // Update UI
            updateGameUI(userMove, aiMove, result);
            
            // Train models after enough data is collected
            if (gameState.userMoves.length >= 5) {
                setTimeout(() => {
                    trainModels();
                }, 0);
            }
        }

        // Predict AI move
        async function predictAiMove(userMove) {
            // Prepare input data
            const inputData = prepareInputData(userMove);
            const tensor = tf.tensor2d([inputData]);
            
            // Get predictions
            const userPred = await gameState.userModel.predict(tensor).array();
            const globalPred = await gameState.globalModel.predict(tensor).array();
            
            // Clean up
            tensor.dispose();
            
            // Blend predictions
            const blendedPred = [
                0.7 * userPred[0][0] + 0.3 * globalPred[0][0],
                0.7 * userPred[0][1] + 0.3 * globalPred[0][1],
                0.7 * userPred[0][2] + 0.3 * globalPred[0][2]
            ];
            
            // Sometimes random for exploration
            if (Math.random() < 0.15) {
                return Math.floor(Math.random() * 3);
            }
            
            return blendedPred.indexOf(Math.max(...blendedPred));
        }

        // Prepare input data for prediction
        function prepareInputData(currentUserMove) {
            const input = [];
            const historyLength = 3;
            
            // Add move history
            for (let i = Math.max(0, gameState.userMoves.length - historyLength); i < gameState.userMoves.length; i++) {
                input.push(...oneHotEncode(gameState.userMoves[i]));
                input.push(...oneHotEncode(gameState.aiMoves[i]));
            }
            
            // Pad with zeros if not enough history
            while (input.length < historyLength * 6) {
                input.push(0, 0, 0);
            }
            
            // Add current user move
            input.push(...oneHotEncode(currentUserMove));
            
            // Add context features
            input.push(gameState.userWins / (gameState.userMoves.length || 1));
            input.push(gameState.aiWins / (gameState.userMoves.length || 1));
            input.push(Math.random());
            input.push((gameState.userMoves.length % 10) / 10);
            
            return input;
        }

        // One-hot encode moves
        function oneHotEncode(move) {
            const index = MOVES.indexOf(move);
            return [
                index === 0 ? 1 : 0,
                index === 1 ? 1 : 0,
                index === 2 ? 1 : 0
            ];
        }

        // Determine winner
        function determineWinner(userMove, aiMove) {
            if (userMove === aiMove) return 'draw';
            
            if (
                (userMove === 'rock' && aiMove === 'scissors') ||
                (userMove === 'paper' && aiMove === 'rock') ||
                (userMove === 'scissors' && aiMove === 'paper')
            ) {
                return 'win';
            }
            
            return 'lose';
        }

        // Train both models
        async function trainModels() {
            // Prepare training data
            const { inputs, labels } = prepareTrainingData();
            const inputTensor = tf.tensor2d(inputs);
            const labelTensor = tf.tensor2d(labels);
            
            try {
                // Train user model
                const userHistory = await gameState.userModel.fit(inputTensor, labelTensor, {
                    epochs: 3,
                    batchSize: 4,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            gameState.userTrainingHistory.loss.push(logs.loss);
                            gameState.userTrainingHistory.accuracy.push(logs.acc);
                            updateUserCharts();
                        }
                    }
                });
                
                // Update user training UI
                document.getElementById('user-cycles').textContent = 
                    parseInt(document.getElementById('user-cycles').textContent) + 3;
                document.getElementById('user-current-accuracy').textContent = 
                    (userHistory.history.acc[userHistory.history.acc.length - 1] * 100).toFixed(1) + '%';
                
                // Train global model less frequently
                if (gameState.userMoves.length % 5 === 0) {
                    const globalHistory = await gameState.globalModel.fit(inputTensor, labelTensor, {
                        epochs: 2,
                        batchSize: 4
                    });
                    
                    // Update global training UI
                    document.getElementById('global-cycles').textContent = 
                        parseInt(document.getElementById('global-cycles').textContent) + 2;
                    document.getElementById('global-current-accuracy').textContent = 
                        (globalHistory.history.acc[globalHistory.history.acc.length - 1] * 100).toFixed(1) + '%';
                    
                    gameState.globalTrainingHistory.loss.push(...globalHistory.history.loss);
                    gameState.globalTrainingHistory.accuracy.push(...globalHistory.history.acc);
                    updateGlobalCharts();
                }
                
                // Save models
                await saveModels();
            } finally {
                // Clean up tensors
                inputTensor.dispose();
                labelTensor.dispose();
            }
        }

        // Prepare training data
        function prepareTrainingData() {
            const inputs = [];
            const labels = [];
            
            for (let i = 3; i < gameState.userMoves.length; i++) {
                const input = [];
                
                // Add previous moves
                for (let j = i - 3; j < i; j++) {
                    if (j >= 0) {
                        input.push(...oneHotEncode(gameState.userMoves[j]));
                        input.push(...oneHotEncode(gameState.aiMoves[j]));
                    } else {
                        input.push(0, 0, 0, 0, 0, 0);
                    }
                }
                
                // Add context
                const winRatio = gameState.userWins / i;
                input.push(winRatio, 1 - winRatio, Math.random(), (i % 10) / 10);
                
                inputs.push(input);
                labels.push(oneHotEncode(getCounterMove(gameState.userMoves[i])));
            }
            
            return { inputs, labels };
        }

        // Get counter move
        function getCounterMove(move) {
            if (move === 'rock') return 'paper';
            if (move === 'paper') return 'scissors';
            return 'rock';
        }

        // Update game UI
        function updateGameUI(userMove, aiMove, result) {
            document.getElementById('ai-choice').textContent = `${MOVE_EMOJIS[aiMove]} ${aiMove}`;
            
            let resultText = '';
            let resultColor = '';
            if (result === 'win') {
                resultText = 'You won!';
                resultColor = '#0f9d58';
            } else if (result === 'lose') {
                resultText = 'AI won!';
                resultColor = '#db4437';
            } else {
                resultText = 'Draw!';
                resultColor = '#f4b400';
            }
            
            document.getElementById('round-result').textContent = resultText;
            document.getElementById('round-result').style.color = resultColor;
            
            // Update stats
            document.getElementById('user-games').textContent = gameState.userMoves.length;
            document.getElementById('user-wins').textContent = gameState.userWins;
            
            const totalGames = gameState.userMoves.length || 1;
            const aiAccuracy = gameState.aiWins / totalGames;
            document.getElementById('ai-accuracy').textContent = `${(aiAccuracy * 100).toFixed(1)}%`;
            document.getElementById('ai-win-rate').textContent = `${(aiAccuracy * 100).toFixed(1)}%`;
            document.getElementById('global-total-games').textContent = totalGames;
        }

        // Initialize charts
        function initCharts() {
            // User loss chart
            gameState.userChartLoss = new Chart(
                document.getElementById('user-loss-chart').getContext('2d'),
                {
                    type: 'line',
                    data: {
                        labels: Array(20).fill('').map((_, i) => i + 1),
                        datasets: [{
                            label: 'Training Loss',
                            data: [],
                            borderColor: '#4285f4',
                            backgroundColor: 'rgba(66, 133, 244, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { y: { beginAtZero: true } }
                    }
                }
            );
            
            // User accuracy chart
            gameState.userChartAccuracy = new Chart(
                document.getElementById('user-accuracy-chart').getContext('2d'),
                {
                    type: 'line',
                    data: {
                        labels: Array(20).fill('').map((_, i) => i + 1),
                        datasets: [{
                            label: 'Training Accuracy',
                            data: [],
                            borderColor: '#0f9d58',
                            backgroundColor: 'rgba(15, 157, 88, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { y: { beginAtZero: true, max: 1 } }
                    }
                }
            );
            
            // Global loss chart
            gameState.globalChartLoss = new Chart(
                document.getElementById('global-loss-chart').getContext('2d'),
                {
                    type: 'line',
                    data: {
                        labels: Array(20).fill('').map((_, i) => i + 1),
                        datasets: [{
                            label: 'Training Loss',
                            data: [],
                            borderColor: '#db4437',
                            backgroundColor: 'rgba(219, 68, 55, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { y: { beginAtZero: true } }
                    }
                }
            );
            
            // Global accuracy chart
            gameState.globalChartAccuracy = new Chart(
                document.getElementById('global-accuracy-chart').getContext('2d'),
                {
                    type: 'line',
                    data: {
                        labels: Array(20).fill('').map((_, i) => i + 1),
                        datasets: [{
                            label: 'Training Accuracy',
                            data: [],
                            borderColor: '#f4b400',
                            backgroundColor: 'rgba(244, 180, 0, 0.1)',
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: { y: { beginAtZero: true, max: 1 } }
                    }
                }
            );
        }

        // Update user charts
        function updateUserCharts() {
            const lossData = gameState.userTrainingHistory.loss.slice(-20);
            const accData = gameState.userTrainingHistory.accuracy.slice(-20);
            
            gameState.userChartLoss.data.datasets[0].data = lossData;
            gameState.userChartLoss.data.labels = lossData.map((_, i) => i + 1);
            gameState.userChartLoss.update();
            
            gameState.userChartAccuracy.data.datasets[0].data = accData;
            gameState.userChartAccuracy.data.labels = accData.map((_, i) => i + 1);
            gameState.userChartAccuracy.update();
        }

        // Update global charts
        function updateGlobalCharts() {
            const lossData = gameState.globalTrainingHistory.loss.slice(-20);
            const accData = gameState.globalTrainingHistory.accuracy.slice(-20);
            
            gameState.globalChartLoss.data.datasets[0].data = lossData;
            gameState.globalChartLoss.data.labels = lossData.map((_, i) => i + 1);
            gameState.globalChartLoss.update();
            
            gameState.globalChartAccuracy.data.datasets[0].data = accData;
            gameState.globalChartAccuracy.data.labels = accData.map((_, i) => i + 1);
            gameState.globalChartAccuracy.update();
        }

        // Show model tab
        function showModel(model) {
            document.querySelectorAll('.model-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.model-content').forEach(content => content.classList.remove('active'));
            
            document.querySelector(`.model-tab[onclick="showModel('${model}')"]`).classList.add('active');
            document.getElementById(`${model}-model`).classList.add('active');
        }

        // Save models to localStorage
        async function saveModels() {
            try {
                // Save user model
                await gameState.userModel.save('localstorage://user-rps-model');
                
                // Save global model
                await gameState.globalModel.save('localstorage://global-rps-model');
                
                // Save game state
                const gameStateToSave = {
                    userMoves: gameState.userMoves,
                    aiMoves: gameState.aiMoves,
                    results: gameState.results,
                    userWins: gameState.userWins,
                    aiWins: gameState.aiWins,
                    draws: gameState.draws,
                    userTrainingHistory: gameState.userTrainingHistory,
                    globalTrainingHistory: gameState.globalTrainingHistory
                };
                
                localStorage.setItem('rps-game-state', JSON.stringify(gameStateToSave));
            } catch (error) {
                console.error('Error saving models:', error);
            }
        }

        // Load models from localStorage
        async function loadModels() {
            try {
                // Load user model
                const userModel = await tf.loadLayersModel('localstorage://user-rps-model');
                if (userModel) gameState.userModel = userModel;
                
                // Load global model
                const globalModel = await tf.loadLayersModel('localstorage://global-rps-model');
                if (globalModel) gameState.globalModel = globalModel;
                
                // Load game state
                const savedState = localStorage.getItem('rps-game-state');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    Object.assign(gameState, parsedState);
                    
                    // Update UI with loaded state
                    updateGameUI('', '', '');
                    updateUserCharts();
                    updateGlobalCharts();
                    
                    document.getElementById('user-cycles').textContent = 
                        gameState.userTrainingHistory.loss.length || '0';
                    document.getElementById('global-cycles').textContent = 
                        gameState.globalTrainingHistory.loss.length || '0';
                }
            } catch (error) {
                console.log('No saved models found, starting fresh');
            }
        }

        // Initialize when page loads
        window.addEventListener('load', initialize);
    </script>
</body>
</html>
