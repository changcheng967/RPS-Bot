<!DOCTYPE html>
<html>
<head>
    <title>RPS AI - Local Learning</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        .choices button {
            font-size: 50px;
            width: 80px;
            height: 80px;
            border: none;
            background: #4285f4;
            color: white;
            border-radius: 50%;
            cursor: pointer;
            margin: 10px;
        }
        #result {
            font-size: 24px;
            margin: 20px 0;
            min-height: 60px;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
        }
        .stat-box {
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
        }
        .win { color: green; }
        .lose { color: red; }
        .draw { color: orange; }
        #training-info {
            margin-top: 20px;
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>Rock Paper Scissors AI</h1>
    
    <div class="choices">
        <button id="rock">✊</button>
        <button id="paper">✋</button>
        <button id="scissors">✌️</button>
    </div>
    
    <div id="result">Make your move!</div>
    
    <div class="stats">
        <div class="stat-box">
            <h3>You</h3>
            <p>Wins: <span id="user-wins">0</span></p>
            <p>Losses: <span id="user-losses">0</span></p>
        </div>
        <div class="stat-box">
            <h3>AI</h3>
            <p>Win Rate: <span id="ai-win-rate">0%</span></p>
            <p>Games: <span id="total-games">0</span></p>
        </div>
    </div>
    
    <div id="training-info">
        <p>Training Cycles: <span id="training-cycles">0</span></p>
    </div>

    <script>
        // Game state
        const game = {
            userWins: 0,
            userLosses: 0,
            draws: 0,
            model: null,
            trainingData: [],
            trainingCycles: 0
        };
        
        // Initialize game
        async function init() {
            // Create model
            game.model = createModel();
            
            // Load saved model if exists
            await loadModel();
            
            // Setup event listeners
            document.getElementById('rock').onclick = () => playRound('rock');
            document.getElementById('paper').onclick = () => playRound('paper');
            document.getElementById('scissors').onclick = () => playRound('scissors');
            
            // Load game stats
            loadGameStats();
        }
        
        // Create neural network
        function createModel() {
            const model = tf.sequential();
            model.add(tf.layers.dense({
                units: 8,
                activation: 'relu',
                inputShape: [4] // Last move + context
            }));
            model.add(tf.layers.dense({
                units: 3, // rock, paper, scissors
                activation: 'softmax'
            }));
            model.compile({
                optimizer: 'adam',
                loss: 'categoricalCrossentropy'
            });
            return model;
        }
        
        // Play a round
        async function playRound(playerMove) {
            // Get AI move
            const aiMove = await getAiMove(playerMove);
            
            // Determine result
            const result = getResult(playerMove, aiMove);
            
            // Update game state
            updateGameState(playerMove, aiMove, result);
            
            // Add to training data
            game.trainingData.push({
                input: prepareInput(playerMove),
                output: oneHotEncode(getCounterMove(playerMove))
            });
            
            // Train periodically
            if (game.trainingData.length >= 5) {
                await trainModel();
                game.trainingData = []; // Clear training data
            }
        }
        
        // Get AI move
        async function getAiMove(playerMove) {
            const moves = ['rock', 'paper', 'scissors'];
            
            // First few moves are random
            if (game.userWins + game.userLosses < 3) {
                return moves[Math.floor(Math.random() * 3)];
            }
            
            try {
                // Prepare input
                const input = prepareInput(playerMove);
                const tensor = tf.tensor2d([input]);
                
                // Get prediction
                const prediction = await game.model.predict(tensor).array();
                tensor.dispose();
                
                // Choose move (with some randomness)
                if (Math.random() < 0.1) {
                    return moves[Math.floor(Math.random() * 3)]; // 10% random exploration
                }
                
                return moves[prediction[0].indexOf(Math.max(...prediction[0]))];
            } catch (error) {
                console.error("Prediction error:", error);
                return moves[Math.floor(Math.random() * 3)]; // Fallback to random
            }
        }
        
        // Prepare input for the neural network
        function prepareInput(playerMove) {
            // Simple input: player move and win ratio
            return [
                playerMove === 'rock' ? 1 : 0,
                playerMove === 'paper' ? 1 : 0,
                playerMove === 'scissors' ? 1 : 0,
                (game.userWins / (game.userWins + game.userLosses || 1)) // Win ratio
            ];
        }
        
        // One-hot encode moves
        function oneHotEncode(move) {
            return [
                move === 'rock' ? 1 : 0,
                move === 'paper' ? 1 : 0,
                move === 'scissors' ? 1 : 0
            ];
        }
        
        // Determine game result
        function getResult(player, ai) {
            if (player === ai) return 'draw';
            if ((player === 'rock' && ai === 'scissors') ||
                (player === 'paper' && ai === 'rock') ||
                (player === 'scissors' && ai === 'paper')) return 'win';
            return 'lose';
        }
        
        // Get counter move
        function getCounterMove(move) {
            return {
                rock: 'paper',
                paper: 'scissors',
                scissors: 'rock'
            }[move];
        }
        
        // Update game state and UI
        function updateGameState(playerMove, aiMove, result) {
            if (result === 'win') game.userWins++;
            if (result === 'lose') game.userLosses++;
            if (result === 'draw') game.draws++;
            
            // Update UI
            document.getElementById('user-wins').textContent = game.userWins;
            document.getElementById('user-losses').textContent = game.userLosses;
            
            const totalGames = game.userWins + game.userLosses;
            const winRate = totalGames > 0 ? Math.round((game.userLosses / totalGames) * 100) : 0;
            document.getElementById('ai-win-rate').textContent = `${winRate}%`;
            document.getElementById('total-games').textContent = game.userWins + game.userLosses + game.draws;
            
            // Show result
            document.getElementById('result').innerHTML = `
                You played <strong>${playerMove}</strong><br>
                AI played <strong>${aiMove}</strong><br>
                <span class="${result}">${result.toUpperCase()}!</span>
            `;
            
            // Save game stats
            saveGameStats();
        }
        
        // Train the model
        async function trainModel() {
            try {
                // Prepare training data
                const inputs = game.trainingData.map(item => item.input);
                const labels = game.trainingData.map(item => item.output);
                
                // Train
                await game.model.fit(
                    tf.tensor2d(inputs),
                    tf.tensor2d(labels),
                    {
                        epochs: 3,
                        batchSize: 2,
                        verbose: 0
                    }
                );
                
                game.trainingCycles++;
                document.getElementById('training-cycles').textContent = game.trainingCycles;
                
                // Save model
                await saveModel();
                
            } catch (error) {
                console.error("Training error:", error);
            }
        }
        
        // Save model to IndexedDB
        async function saveModel() {
            try {
                await game.model.save('localstorage://rps-ai-model');
            } catch (error) {
                console.error("Error saving model:", error);
            }
        }
        
        // Load model from IndexedDB
        async function loadModel() {
            try {
                const model = await tf.loadLayersModel('localstorage://rps-ai-model');
                if (model) {
                    game.model = model;
                    console.log("Model loaded from local storage");
                }
            } catch (error) {
                console.log("No saved model found, starting fresh");
            }
        }
        
        // Save game stats to localStorage
        function saveGameStats() {
            localStorage.setItem('rps-game-stats', JSON.stringify({
                wins: game.userWins,
                losses: game.userLosses,
                draws: game.draws,
                trainingCycles: game.trainingCycles
            }));
        }
        
        // Load game stats from localStorage
        function loadGameStats() {
            const saved = localStorage.getItem('rps-game-stats');
            if (saved) {
                const stats = JSON.parse(saved);
                game.userWins = stats.wins || 0;
                game.userLosses = stats.losses || 0;
                game.draws = stats.draws || 0;
                game.trainingCycles = stats.trainingCycles || 0;
                
                // Update UI
                document.getElementById('user-wins').textContent = game.userWins;
                document.getElementById('user-losses').textContent = game.userLosses;
                document.getElementById('training-cycles').textContent = game.trainingCycles;
                
                const totalGames = game.userWins + game.userLosses;
                const winRate = totalGames > 0 ? Math.round((game.userLosses / totalGames) * 100) : 0;
                document.getElementById('ai-win-rate').textContent = `${winRate}%`;
                document.getElementById('total-games').textContent = game.userWins + game.userLosses + game.draws;
            }
        }
        
        // Start the game
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
