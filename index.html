<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate RPS AI</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
            background-color: #f8f9fa;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #7f8c8d;
            margin-bottom: 30px;
        }
        .choices {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 40px 0;
            flex-wrap: wrap;
        }
        .choice {
            font-size: 70px;
            cursor: pointer;
            padding: 15px;
            border-radius: 15px;
            transition: all 0.3s;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .choice:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
        }
        #result {
            font-size: 26px;
            margin: 30px 0;
            min-height: 120px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .stats-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
            margin: 30px 0;
        }
        .stat-box {
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            min-width: 150px;
        }
        .analysis {
            margin-top: 40px;
            padding: 20px;
            background-color: #2c3e50;
            color: white;
            border-radius: 10px;
            text-align: left;
        }
        .strategy-tag {
            display: inline-block;
            padding: 3px 8px;
            background-color: #e74c3c;
            color: white;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        #confidence-meter {
            height: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        #confidence-level {
            height: 100%;
            background-color: #2ecc71;
            width: 0%;
            transition: width 0.5s;
        }
    </style>
</head>
<body>
    <h1>Ultimate RPS AI</h1>
    <p class="subtitle">The most advanced pattern-recognition Rock-Paper-Scissors AI</p>
    
    <div class="choices">
        <div class="choice" data-choice="rock">✊</div>
        <div class="choice" data-choice="paper">✋</div>
        <div class="choice" data-choice="scissors">✌️</div>
    </div>
    
    <div id="result">Make your move!</div>
    
    <div class="stats-container">
        <div class="stat-box">
            <h3>Games Played</h3>
            <p id="games-played">0</p>
        </div>
        <div class="stat-box">
            <h3>Your Wins</h3>
            <p id="user-wins">0</p>
        </div>
        <div class="stat-box">
            <h3>AI Wins</h3>
            <p id="bot-wins">0</p>
        </div>
        <div class="stat-box">
            <h3>Win Rate</h3>
            <p id="win-rate">0%</p>
        </div>
    </div>
    
    <div class="analysis">
        <h2>AI Analysis</h2>
        <div id="pattern-info">Collecting initial data...</div>
        <div id="confidence">
            <div>Prediction Confidence: <span id="confidence-value">0</span>%</div>
            <div id="confidence-meter">
                <div id="confidence-level"></div>
            </div>
        </div>
        <div id="strategy-tags"></div>
    </div>
    
    <script>
        // Enhanced game state
        const state = {
            gamesPlayed: 0,
            userWins: 0,
            botWins: 0,
            ties: 0,
            history: [],
            moveCounts: { rock: 0, paper: 0, scissors: 0 },
            
            // Multi-order Markov chains
            transitions: {
                order1: {
                    rock: { rock: 0, paper: 0, scissors: 0 },
                    paper: { rock: 0, paper: 0, scissors: 0 },
                    scissors: { rock: 0, paper: 0, scissors: 0 }
                },
                order2: {
                    'rock-rock': { rock: 0, paper: 0, scissors: 0 },
                    'rock-paper': { rock: 0, paper: 0, scissors: 0 },
                    // ... all 9 possible combinations
                    'scissors-scissors': { rock: 0, paper: 0, scissors: 0 }
                }
            },
            
            // Strategy detection
            detectedStrategies: new Set(),
            strategyHistory: [],
            confidence: 0,
            
            // Anti-pattern measures
            lastBotMove: null,
            streak: 0,
            lastStreakMove: null
        };

        // Initialize all order2 transitions
        const moves = ['rock', 'paper', 'scissors'];
        moves.forEach(move1 => {
            moves.forEach(move2 => {
                state.transitions.order2[`${move1}-${move2}`] = { rock: 0, paper: 0, scissors: 0 };
            });
        });

        // Move relationships
        const beats = {
            rock: 'scissors',
            paper: 'rock',
            scissors: 'paper'
        };
        
        const moveToEmoji = {
            rock: '✊',
            paper: '✋',
            scissors: '✌️'
        };
        
        const moveNames = {
            rock: 'Rock',
            paper: 'Paper',
            scissors: 'Scissors'
        };
        
        // Known player strategies to detect
        const STRATEGIES = {
            WIN_STAY: 'win-stay/lose-shift',
            GAMBLERS_FALLACY: 'gambler\'s fallacy',
            COUNTER_BOT: 'countering bot patterns',
            RANDOM: 'pseudo-random',
            FREQUENCY_BIAS: 'frequency bias',
            REPEAT_AVOIDANCE: 'repeat avoidance'
        };

        // DOM elements
        const resultEl = document.getElementById('result');
        const patternInfoEl = document.getElementById('pattern-info');
        const confidenceValueEl = document.getElementById('confidence-value');
        const confidenceLevelEl = document.getElementById('confidence-level');
        const strategyTagsEl = document.getElementById('strategy-tags');
        
        // Event listeners
        document.querySelectorAll('.choice').forEach(choice => {
            choice.addEventListener('click', (e) => {
                const userChoice = e.target.getAttribute('data-choice');
                playGame(userChoice);
            });
        });

        function playGame(userChoice) {
            state.gamesPlayed++;
            state.moveCounts[userChoice]++;
            
            // Update transition matrices
            updateTransitions(userChoice);
            
            // Bot makes its choice using advanced decision making
            const { botChoice, confidence, strategy } = makeAdvancedDecision();
            state.confidence = confidence;
            
            // Determine winner
            let result;
            if (userChoice === botChoice) {
                result = 'tie';
                state.ties++;
            } else if (beats[userChoice] === botChoice) {
                result = 'user';
                state.userWins++;
            } else {
                result = 'bot';
                state.botWins++;
            }
            
            // Update game state
            state.history.push(userChoice);
            state.lastBotMove = botChoice;
            updateStreak(result);
            
            // Update UI
            updateUI(userChoice, botChoice, result, strategy);
            detectStrategies(userChoice);
        }
        
        function updateTransitions(userChoice) {
            // Update order1 transitions
            if (state.history.length > 0) {
                const lastMove = state.history[state.history.length - 1];
                state.transitions.order1[lastMove][userChoice]++;
            }
            
            // Update order2 transitions
            if (state.history.length > 1) {
                const lastTwo = state.history.slice(-2);
                const key = `${lastTwo[0]}-${lastTwo[1]}`;
                state.transitions.order2[key][userChoice]++;
            }
        }
        
        function makeAdvancedDecision() {
            if (state.gamesPlayed < 3) {
                // Not enough data - use basic frequency
                return {
                    botChoice: counterMostCommonMove(),
                    confidence: 0,
                    strategy: 'Initial frequency analysis'
                };
            }
            
            // Try multiple prediction methods with fallbacks
            const predictions = [];
            
            // 1. Second-order Markov prediction
            if (state.history.length >= 2) {
                const lastTwo = state.history.slice(-2);
                const key = `${lastTwo[0]}-${lastTwo[1]}`;
                const prediction = predictFromTransitions(state.transitions.order2[key]);
                if (prediction.confidence > 0.6) {
                    predictions.push({
                        move: beats[prediction.move],
                        confidence: prediction.confidence,
                        strategy: 'Second-order pattern recognition'
                    });
                }
            }
            
            // 2. First-order Markov prediction
            const lastMove = state.history[state.history.length - 1];
            const prediction1 = predictFromTransitions(state.transitions.order1[lastMove]);
            if (prediction1.confidence > 0.55) {
                predictions.push({
                    move: beats[prediction1.move],
                    confidence: prediction1.confidence,
                    strategy: 'First-order pattern recognition'
                });
            }
            
            // 3. Frequency analysis with decay (recent moves weighted more)
            const freqPrediction = predictFromFrequency();
            predictions.push({
                move: beats[freqPrediction.move],
                confidence: freqPrediction.confidence,
                strategy: 'Weighted frequency analysis'
            });
            
            // 4. Anti-pattern measures (if we're being too predictable)
            if (state.streak >= 3 && state.lastStreakMove) {
                predictions.push({
                    move: beats[beats[state.lastStreakMove]], // Counter what would counter our last move
                    confidence: Math.min(0.7, state.confidence + 0.1),
                    strategy: 'Anti-pattern adjustment'
                });
            }
            
            // 5. Strategy-specific counters
            if (state.detectedStrategies.size > 0) {
                let strategyResponse = null;
                
                if (state.detectedStrategies.has(STRATEGIES.WIN_STAY)) {
                    // If player tends to repeat winning moves
                    if (state.userWins > 0 && state.history.length > 1) {
                        const lastUserWin = [...state.history].reverse().find((_, i, arr) => {
                            const idx = arr.length - 1 - i;
                            return idx > 0 && beats[state.history[idx]] === state.history[idx - 1];
                        });
                        if (lastUserWin) {
                            strategyResponse = {
                                move: beats[lastUserWin],
                                confidence: 0.65,
                                strategy: 'Countering win-stay'
                            };
                        }
                    }
                }
                
                if (state.detectedStrategies.has(STRATEGIES.REPEAT_AVOIDANCE)) {
                    // If player avoids repeating moves
                    const lastMove = state.history[state.history.length - 1];
                    const possibleMoves = moves.filter(m => m !== lastMove);
                    if (possibleMoves.length === 2) {
                        // Predict which of the two they're more likely to choose
                        const move1Count = state.moveCounts[possibleMoves[0]];
                        const move2Count = state.moveCounts[possibleMoves[1]];
                        const predicted = move1Count > move2Count ? possibleMoves[0] : possibleMoves[1];
                        strategyResponse = {
                            move: beats[predicted],
                            confidence: 0.6,
                            strategy: 'Countering repeat avoidance'
                        };
                    }
                }
                
                if (strategyResponse) {
                    predictions.push(strategyResponse);
                }
            }
            
            // Select the prediction with highest confidence
            if (predictions.length > 0) {
                predictions.sort((a, b) => b.confidence - a.confidence);
                const bestPrediction = predictions[0];
                
                // Occasionally introduce randomness to avoid being too predictable
                if (Math.random() < 0.05) { // 5% chance to randomize
                    return {
                        botChoice: randomMove(),
                        confidence: bestPrediction.confidence * 0.7,
                        strategy: 'Randomized ' + bestPrediction.strategy
                    };
                }
                
                return bestPrediction;
            }
            
            // Fallback to countering most common move
            return {
                botChoice: counterMostCommonMove(),
                confidence: 0.5,
                strategy: 'Frequency fallback'
            };
        }
        
        function predictFromTransitions(transitionCounts) {
            const total = Object.values(transitionCounts).reduce((a, b) => a + b, 0);
            if (total === 0) return { move: null, confidence: 0 };
            
            let maxCount = -1;
            let predicted = null;
            
            for (const [move, count] of Object.entries(transitionCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    predicted = move;
                }
            }
            
            const confidence = maxCount / total;
            return { move: predicted, confidence };
        }
        
        function predictFromFrequency() {
            // Weight recent moves more heavily
            const recentMoves = state.history.slice(-5);
            const recentCounts = { rock: 0, paper: 0, scissors: 0 };
            recentMoves.forEach(move => recentCounts[move]++);
            
            // Combine with overall frequencies (weighted less)
            const totalWeight = recentMoves.length + state.history.length;
            const rockWeight = (recentCounts.rock * 0.7 + state.moveCounts.rock * 0.3) / totalWeight;
            const paperWeight = (recentCounts.paper * 0.7 + state.moveCounts.paper * 0.3) / totalWeight;
            const scissorsWeight = (recentCounts.scissors * 0.7 + state.moveCounts.scissors * 0.3) / totalWeight;
            
            let predicted = null;
            let maxWeight = -1;
            
            if (rockWeight > maxWeight) {
                maxWeight = rockWeight;
                predicted = 'rock';
            }
            if (paperWeight > maxWeight) {
                maxWeight = paperWeight;
                predicted = 'paper';
            }
            if (scissorsWeight > maxWeight) {
                maxWeight = scissorsWeight;
                predicted = 'scissors';
            }
            
            // Confidence based on how dominant the prediction is
            const sum = rockWeight + paperWeight + scissorsWeight;
            const normalizedWeights = {
                rock: rockWeight / sum,
                paper: paperWeight / sum,
                scissors: scissorsWeight / sum
            };
            
            const confidence = (maxWeight / sum) - Math.max(
                ...Object.values(normalizedWeights).filter(w => w !== maxWeight)
            );
            
            return { move: predicted, confidence: Math.max(0.3, confidence) };
        }
        
        function counterMostCommonMove() {
            const maxMove = Object.entries(state.moveCounts).reduce(
                (max, [move, count]) => count > max.count ? { move, count } : max,
                { move: null, count: -1 }
            ).move;
            
            return maxMove ? beats[maxMove] : randomMove();
        }
        
        function randomMove() {
            return moves[Math.floor(Math.random() * moves.length)];
        }
        
        function updateStreak(result) {
            if (result === 'bot') {
                if (state.streak >= 0) {
                    state.streak++;
                } else {
                    state.streak = 1;
                }
                state.lastStreakMove = state.lastBotMove;
            } else if (result === 'user') {
                if (state.streak <= 0) {
                    state.streak--;
                } else {
                    state.streak = -1;
                }
            } else {
                // Tie doesn't affect streak
            }
        }
        
        function detectStrategies(userChoice) {
            // Detect win-stay/lose-shift
            if (state.history.length >= 3) {
                const lastGameResult = getGameResult(state.history.length - 2);
                const lastMove = state.history[state.history.length - 2];
                const currentMove = state.history[state.history.length - 1];
                
                if (lastGameResult === 'user' && lastMove === currentMove) {
                    state.strategyHistory.push(STRATEGIES.WIN_STAY);
                } else if (lastGameResult === 'bot' && lastMove !== currentMove) {
                    state.strategyHistory.push(STRATEGIES.WIN_STAY);
                }
            }
            
            // Detect repeat avoidance
            if (state.history.length >= 4) {
                const uniqueLastThree = new Set(state.history.slice(-3));
                if (uniqueLastThree.size === 3) {
                    state.strategyHistory.push(STRATEGIES.REPEAT_AVOIDANCE);
                }
            }
            
            // Detect gambler's fallacy (avoiding moves that haven't come up in a while)
            if (state.history.length >= 5) {
                const recentMoves = state.history.slice(-5);
                const missingMoves = moves.filter(m => !recentMoves.includes(m));
                if (missingMoves.length === 1 && !missingMoves.includes(userChoice)) {
                    state.strategyHistory.push(STRATEGIES.GAMBLERS_FALLACY);
                }
            }
            
            // Update detected strategies based on frequency in history
            state.detectedStrategies = new Set();
            const strategyCounts = {};
            
            state.strategyHistory.forEach(strategy => {
                strategyCounts[strategy] = (strategyCounts[strategy] || 0) + 1;
            });
            
            for (const [strategy, count] of Object.entries(strategyCounts)) {
                if (count / state.strategyHistory.length > 0.3) { // At least 30% occurrence
                    state.detectedStrategies.add(strategy);
                }
            }
        }
        
        function getGameResult(index) {
            if (index <= 0 || index >= state.history.length) return null;
            
            const userMove = state.history[index];
            const botMove = state.history[index - 1]; // Note: this would need adjustment in real code
            
            if (userMove === botMove) return 'tie';
            return beats[userMove] === botMove ? 'user' : 'bot';
        }
        
        function updateUI(userChoice, botChoice, result, strategy) {
            // Update result display
            let resultText = `You chose ${moveToEmoji[userChoice]} ${moveNames[userChoice]}, `;
            resultText += `AI chose ${moveToEmoji[botChoice]} ${moveNames[botChoice]}. `;
            
            switch (result) {
                case 'user':
                    resultText += '<span style="color:#2ecc71;">You win!</span>';
                    break;
                case 'bot':
                    resultText += '<span style="color:#e74c3c;">AI wins!</span>';
                    break;
                case 'tie':
                    resultText += '<span style="color:#3498db;">It\'s a tie!</span>';
                    break;
            }
            
            resultText += `<br><small>AI Strategy: ${strategy}</small>`;
            resultEl.innerHTML = resultText;
            
            // Update stats
            document.getElementById('games-played').textContent = state.gamesPlayed;
            document.getElementById('user-wins').textContent = state.userWins;
            document.getElementById('bot-wins').textContent = state.botWins;
            document.getElementById('win-rate').textContent = 
                ((state.botWins / state.gamesPlayed) * 100).toFixed(1) + '%';
            
            // Update confidence meter
            confidenceValueEl.textContent = Math.round(state.confidence * 100);
            confidenceLevelEl.style.width = `${state.confidence * 100}%`;
            
            // Update pattern info
            updatePatternInfo();
            
            // Update strategy tags
            updateStrategyTags();
        }
        
        function updatePatternInfo() {
            if (state.gamesPlayed < 3) {
                patternInfoEl.textContent = 'Collecting initial data patterns...';
                return;
            }
            
            const analysis = [];
            
            // Frequency analysis
            const total = state.gamesPlayed;
            const rockPct = (state.moveCounts.rock / total * 100).toFixed(1);
            const paperPct = (state.moveCounts.paper / total * 100).toFixed(1);
            const scissorsPct = (state.moveCounts.scissors / total * 100).toFixed(1);
            
            analysis.push(`<strong>Move frequencies:</strong> Rock ${rockPct}%, Paper ${paperPct}%, Scissors ${scissorsPct}%`);
            
            // Recent moves
            if (state.history.length >= 3) {
                const recent = state.history.slice(-3).map(m => moveNames[m]).join(' → ');
                analysis.push(`<strong>Recent sequence:</strong> ${recent}`);
            }
            
            // Transition probabilities
            if (state.history.length >= 2) {
                const lastMove = state.history[state.history.length - 1];
                const transitions = state.transitions.order1[lastMove];
                const totalTransitions = Object.values(transitions).reduce((a, b) => a + b, 0);
                
                if (totalTransitions > 0) {
                    const rockNext = (transitions.rock / totalTransitions * 100).toFixed(1);
                    const paperNext = (transitions.paper / totalTransitions * 100).toFixed(1);
                    const scissorsNext = (transitions.scissors / totalTransitions * 100).toFixed(1);
                    
                    analysis.push(`After ${moveNames[lastMove]}, you usually throw: Rock ${rockNext}%, Paper ${paperNext}%, Scissors ${scissorsNext}%`);
                }
            }
            
            patternInfoEl.innerHTML = analysis.join('<br>');
        }
        
        function updateStrategyTags() {
            if (state.detectedStrategies.size === 0) {
                strategyTagsEl.innerHTML = 'No strong strategy patterns detected yet';
                return;
            }
            
            strategyTagsEl.innerHTML = '<strong>Detected Player Strategies:</strong><br>';
            state.detectedStrategies.forEach(strategy => {
                strategyTagsEl.innerHTML += `<span class="strategy-tag">${strategy}</span>`;
            });
        }
    </script>
</body>
</html>
