<!DOCTYPE html>
<html>
<head>
    <title>RPS AI - Advanced Local Learning</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        .choices button {
            font-size: 50px;
            width: 80px;
            height: 80px;
            border: none;
            background: #4285f4;
            color: white;
            border-radius: 50%;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
        }
        .choices button:hover {
            transform: scale(1.1);
        }
        #result {
            font-size: 24px;
            margin: 20px 0;
            min-height: 60px;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
        }
        .stat-box {
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
        }
        .win { color: #2ecc71; }
        .lose { color: #e74c3c; }
        .draw { color: #f39c12; }
        #training-panel {
            margin-top: 20px;
            padding: 15px;
            background: #e8f4f8;
            border-radius: 5px;
        }
        #training-progress {
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        #training-bar {
            height: 100%;
            background: #3498db;
            width: 0%;
            transition: width 0.3s;
        }
        .contributor-badge {
            display: inline-block;
            background: #2ecc71;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            margin-left: 5px;
        }
        #device-id {
            font-family: monospace;
            background: #f0f0f0;
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>Rock Paper Scissors AI</h1>
    <p>Training on <span id="device-id">this device</span></p>
    
    <div class="choices">
        <button id="rock">✊</button>
        <button id="paper">✋</button>
        <button id="scissors">✌️</button>
    </div>
    
    <div id="result">Make your move!</div>
    
    <div class="stats">
        <div class="stat-box">
            <h3>You</h3>
            <p>Wins: <span id="user-wins">0</span></p>
            <p>Losses: <span id="user-losses">0</span></p>
        </div>
        <div class="stat-box">
            <h3>AI</h3>
            <p>Win Rate: <span id="ai-win-rate">0%</span></p>
            <p>Games: <span id="total-games">0</span></p>
        </div>
    </div>
    
    <div id="training-panel">
        <h3>Training Progress</h3>
        <div id="training-progress">
            <div id="training-bar"></div>
        </div>
        <p>Cycles: <span id="training-cycles">0</span> | Accuracy: <span id="training-accuracy">0%</span></p>
        <p>Data Points: <span id="data-points">0</span> | Last Trained: <span id="last-trained">Never</span></p>
        <p>Contributor Level: <span id="contributor-level">Novice</span><span id="contributor-badge" class="contributor-badge" style="display:none">⭐</span></p>
    </div>

    <script>
        // Game state
        const game = {
            userWins: 0,
            userLosses: 0,
            draws: 0,
            model: null,
            trainingData: [],
            trainingCycles: 0,
            trainingSamples: 0,
            deviceId: null,
            lastTrained: null,
            contributorLevel: 0
        };
        
        // Generate a persistent device ID
        function getDeviceId() {
            let id = localStorage.getItem('rps-device-id');
            if (!id) {
                id = 'd-' + Math.random().toString(36).substr(2, 8);
                localStorage.setItem('rps-device-id', id);
            }
            return id;
        }
        
        // Initialize game
        async function init() {
            // Get device ID
            game.deviceId = getDeviceId();
            document.getElementById('device-id').textContent = game.deviceId;
            
            // Create model
            game.model = createModel();
            
            // Load saved data
            await loadAllData();
            
            // Setup event listeners
            setupControls();
            
            // Update UI
            updateUI();
        }
        
        // Create neural network
        function createModel() {
            const model = tf.sequential();
            model.add(tf.layers.dense({
                units: 12,
                activation: 'relu',
                inputShape: [6] // Last 2 moves + context
            }));
            model.add(tf.layers.dense({
                units: 8,
                activation: 'relu'
            }));
            model.add(tf.layers.dense({
                units: 3, // rock, paper, scissors
                activation: 'softmax'
            }));
            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            return model;
        }
        
        // Setup game controls
        function setupControls() {
            document.getElementById('rock').onclick = () => playRound('rock');
            document.getElementById('paper').onclick = () => playRound('paper');
            document.getElementById('scissors').onclick = () => playRound('scissors');
        }
        
        // Play a round
        async function playRound(playerMove) {
            // Get AI move
            const aiMove = await getAiMove(playerMove);
            
            // Determine result
            const result = getResult(playerMove, aiMove);
            
            // Update game state
            updateGameState(playerMove, aiMove, result);
            
            // Add to training data
            addTrainingData(playerMove, aiMove, result);
            
            // Train periodically
            if (game.trainingData.length >= 5) {
                await trainModel();
            }
        }
        
        // Get AI move
        async function getAiMove(playerMove) {
            const moves = ['rock', 'paper', 'scissors'];
            
            // First few moves are random
            if (game.userWins + game.userLosses < 3) {
                return moves[Math.floor(Math.random() * 3)];
            }
            
            try {
                // Prepare input
                const input = prepareInput(playerMove);
                const tensor = tf.tensor2d([input]);
                
                // Get prediction
                const prediction = await game.model.predict(tensor).array();
                tensor.dispose();
                
                // Choose move (with some randomness)
                if (Math.random() < 0.15) {
                    return moves[Math.floor(Math.random() * 3)]; // 15% random exploration
                }
                
                return moves[prediction[0].indexOf(Math.max(...prediction[0]))];
            } catch (error) {
                console.error("Prediction error:", error);
                return moves[Math.floor(Math.random() * 3)]; // Fallback to random
            }
        }
        
        // Prepare input for prediction
        function prepareInput(playerMove) {
            // Use last 2 moves as context
            const history = game.trainingData.slice(-2);
            const input = [];
            
            // Add history (pad with zeros if not enough history)
            history.forEach(item => {
                input.push(...oneHotEncode(item.playerMove));
                input.push(...oneHotEncode(item.aiMove));
            });
            
            // Pad if not enough history
            while (input.length < 6) input.push(0);
            
            return input;
        }
        
        // One-hot encode moves
        function oneHotEncode(move) {
            return [
                move === 'rock' ? 1 : 0,
                move === 'paper' ? 1 : 0,
                move === 'scissors' ? 1 : 0
            ];
        }
        
        // Determine game result
        function getResult(player, ai) {
            if (player === ai) return 'draw';
            if ((player === 'rock' && ai === 'scissors') ||
                (player === 'paper' && ai === 'rock') ||
                (player === 'scissors' && ai === 'paper')) return 'win';
            return 'lose';
        }
        
        // Update game state
        function updateGameState(playerMove, aiMove, result) {
            if (result === 'win') game.userWins++;
            if (result === 'lose') game.userLosses++;
            if (result === 'draw') game.draws++;
            
            // Update contributor level
            updateContributorLevel();
            
            // Save game state
            saveGameStats();
            
            // Update UI
            updateUI(playerMove, aiMove, result);
        }
        
        // Add training data
        function addTrainingData(playerMove, aiMove, result) {
            game.trainingData.push({
                playerMove,
                aiMove,
                result,
                timestamp: new Date().toISOString()
            });
            
            // Limit to 100 most recent games
            if (game.trainingData.length > 100) {
                game.trainingData.shift();
            }
            
            // Save training data
            saveTrainingData();
        }
        
        // Train the model
        async function trainModel() {
            if (game.trainingData.length < 3) return;
            
            try {
                // Prepare training data
                const inputs = [];
                const labels = [];
                
                // Create training examples from history
                for (let i = 2; i < game.trainingData.length; i++) {
                    const prev1 = game.trainingData[i-1];
                    const prev2 = game.trainingData[i-2];
                    const current = game.trainingData[i];
                    
                    // Input: previous moves + context
                    inputs.push([
                        ...oneHotEncode(prev1.playerMove),
                        ...oneHotEncode(prev1.aiMove),
                        ...oneHotEncode(prev2.playerMove),
                        ...oneHotEncode(prev2.aiMove)
                    ]);
                    
                    // Label: what would have beaten the player's move
                    labels.push(oneHotEncode(getCounterMove(current.playerMove)));
                }
                
                // Show training started
                document.getElementById('training-bar').style.width = '10%';
                
                // Train
                const history = await game.model.fit(
                    tf.tensor2d(inputs),
                    tf.tensor2d(labels),
                    {
                        epochs: 5,
                        batchSize: 4,
                        callbacks: {
                            onEpochEnd: async (epoch, logs) => {
                                // Update progress bar
                                const progress = 10 + ((epoch + 1) / 5 * 90);
                                document.getElementById('training-bar').style.width = `${progress}%`;
                                
                                // Update accuracy
                                document.getElementById('training-accuracy').textContent = 
                                    `${Math.round(logs.acc * 100)}%`;
                            }
                        }
                    }
                );
                
                // Update training stats
                game.trainingCycles++;
                game.trainingSamples += inputs.length;
                game.lastTrained = new Date();
                
                // Update contributor level
                updateContributorLevel();
                
                // Save everything
                await saveAllData();
                
                // Update UI
                updateTrainingUI(history);
                
            } catch (error) {
                console.error("Training error:", error);
                document.getElementById('training-bar').style.width = '0%';
            }
        }
        
        // Update contributor level
        function updateContributorLevel() {
            const totalGames = game.userWins + game.userLosses + game.draws;
            game.contributorLevel = Math.floor(totalGames / 20); // Level up every 20 games
            
            const levels = ['Novice', 'Apprentice', 'Regular', 'Expert', 'Master'];
            const levelName = levels[Math.min(game.contributorLevel, levels.length - 1)];
            
            document.getElementById('contributor-level').textContent = levelName;
            
            // Show badge after level 1
            const badge = document.getElementById('contributor-badge');
            if (game.contributorLevel > 0) {
                badge.style.display = 'inline-block';
                badge.textContent = '⭐'.repeat(Math.min(game.contributorLevel, 5));
            } else {
                badge.style.display = 'none';
            }
        }
        
        // Update UI
        function updateUI(playerMove, aiMove, result) {
            // Update stats
            document.getElementById('user-wins').textContent = game.userWins;
            document.getElementById('user-losses').textContent = game.userLosses;
            
            const totalGames = game.userWins + game.userLosses || 1;
            const winRate = Math.round((game.userLosses / totalGames) * 100);
            document.getElementById('ai-win-rate').textContent = `${winRate}%`;
            document.getElementById('total-games').textContent = game.userWins + game.userLosses + game.draws;
            
            // Update result display
            if (playerMove && aiMove) {
                document.getElementById('result').innerHTML = `
                    You played <strong>${playerMove}</strong><br>
                    AI played <strong>${aiMove}</strong><br>
                    <span class="${result}">${result.toUpperCase()}!</span>
                `;
            }
            
            // Update data points
            document.getElementById('data-points').textContent = game.trainingData.length;
        }
        
        // Update training UI
        function updateTrainingUI(history) {
            document.getElementById('training-cycles').textContent = game.trainingCycles;
            document.getElementById('last-trained').textContent = 
                game.lastTrained ? game.lastTrained.toLocaleTimeString() : 'Never';
            
            // Get final accuracy
            const accuracy = history.history.acc[history.history.acc.length - 1];
            document.getElementById('training-accuracy').textContent = 
                `${Math.round(accuracy * 100)}%`;
        }
        
        // Save all data
        async function saveAllData() {
            await saveModel();
            saveGameStats();
            saveTrainingData();
        }
        
        // Save model to IndexedDB
        async function saveModel() {
            try {
                await game.model.save('indexeddb://rps-ai-model');
            } catch (error) {
                console.error("Error saving model:", error);
            }
        }
        
        // Save game stats to localStorage
        function saveGameStats() {
            localStorage.setItem('rps-game-stats', JSON.stringify({
                wins: game.userWins,
                losses: game.userLosses,
                draws: game.draws,
                trainingCycles: game.trainingCycles,
                trainingSamples: game.trainingSamples,
                lastTrained: game.lastTrained,
                contributorLevel: game.contributorLevel
            }));
        }
        
        // Save training data to localStorage
        function saveTrainingData() {
            // Only save the most recent 50 games for training
            const recentData = game.trainingData.slice(-50);
            localStorage.setItem('rps-training-data', JSON.stringify(recentData));
        }
        
        // Load all data
        async function loadAllData() {
            await loadModel();
            loadGameStats();
            loadTrainingData();
        }
        
        // Load model from IndexedDB
        async function loadModel() {
            try {
                const models = await tf.io.listModels();
                if (models['indexeddb://rps-ai-model']) {
                    game.model = await tf.loadLayersModel('indexeddb://rps-ai-model');
                    console.log("Model loaded from IndexedDB");
                }
            } catch (error) {
                console.log("No saved model found, starting fresh");
            }
        }
        
        // Load game stats from localStorage
        function loadGameStats() {
            const saved = localStorage.getItem('rps-game-stats');
            if (saved) {
                const stats = JSON.parse(saved);
                game.userWins = stats.wins || 0;
                game.userLosses = stats.losses || 0;
                game.draws = stats.draws || 0;
                game.trainingCycles = stats.trainingCycles || 0;
                game.trainingSamples = stats.trainingSamples || 0;
                game.lastTrained = stats.lastTrained ? new Date(stats.lastTrained) : null;
                game.contributorLevel = stats.contributorLevel || 0;
            }
        }
        
        // Load training data from localStorage
        function loadTrainingData() {
            const saved = localStorage.getItem('rps-training-data');
            if (saved) {
                game.trainingData = JSON.parse(saved) || [];
            }
        }
        
        // Start the game
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
