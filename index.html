<!DOCTYPE html>
<html>
<head>
    <title>Elite RPS AI</title>
    <style>
        /* Modern UI with animations */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }
        .choice {
            font-size: 5rem;
            cursor: pointer;
            margin: 1rem;
            padding: 1.5rem;
            display: inline-block;
            transition: all 0.3s ease;
            border-radius: 50%;
            background: white;
            box-shadow: 0 6px 10px rgba(0,0,0,0.1);
            width: 100px;
            height: 100px;
            line-height: 100px;
        }
        .choice:hover {
            transform: scale(1.15) rotate(8deg);
            box-shadow: 0 10px 20px rgba(0,0,0,0.15);
        }
        #result {
            font-size: 1.8rem;
            margin: 2rem 0;
            min-height: 100px;
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }
        .stat {
            padding: 1rem;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #loading {
            font-size: 1.2rem;
            margin: 2rem 0;
        }
        #ai-thinking {
            display: none;
            font-size: 1.2rem;
            margin: 1rem 0;
        }
        .progress-bar {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin: 1rem auto;
            max-width: 300px;
            overflow: hidden;
        }
        .progress {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            width: 0%;
            transition: width 0.3s ease;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .pulse {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <h1>Elite RPS AI</h1>
    <p>A multi-strategy AI combining Python and JavaScript models</p>
    
    <div id="loading" class="pulse">
        <div>Loading AI engines...</div>
        <div class="progress-bar">
            <div class="progress" id="load-progress"></div>
        </div>
    </div>
    
    <div id="game" style="display:none">
        <div>
            <div class="choice" data-move="0">✊</div>
            <div class="choice" data-move="1">✋</div>
            <div class="choice" data-move="2">✌️</div>
        </div>
        
        <div id="ai-thinking" style="display:none">
            <div>AI analyzing your patterns...</div>
            <div class="progress-bar">
                <div class="progress" id="ai-progress"></div>
            </div>
        </div>
        
        <div id="result">Make your move!</div>
        
        <div class="stats">
            <div class="stat">Games: <span id="games">0</span></div>
            <div class="stat">You: <span id="wins">0</span></div>
            <div class="stat">AI: <span id="ai-wins">0</span></div>
            <div class="stat">Draws: <span id="draws">0</span></div>
            <div class="stat">Win Rate: <span id="win-rate">0</span>%</div>
        </div>
    </div>

    <script>
        // Game state
        const game = {
            history: [],
            games: 0,
            wins: 0,
            aiWins: 0,
            draws: 0,
            moveNames: ['Rock ✊', 'Paper ✋', 'Scissors ✌️'],
            strategies: [],
            activeStrategy: null
        };

        // ========================
        // JavaScript AI Strategies
        // ========================
        
        // 1. Frequency Analysis Strategy
        class FrequencyStrategy {
            constructor() {
                this.moveCounts = [0, 0, 0];
            }
            
            update(move) {
                this.moveCounts[move]++;
            }
            
            predict() {
                // Find least used move and counter it
                const leastUsed = this.moveCounts.indexOf(Math.min(...this.moveCounts));
                return (leastUsed + 1) % 3;
            }
        }
        
        // 2. Pattern Recognition Strategy
        class PatternStrategy {
            constructor() {
                this.patterns = {};
                this.lastMoves = [];
                this.patternLength = 3;
            }
            
            update(move) {
                this.lastMoves.push(move);
                if (this.lastMoves.length > this.patternLength) {
                    this.lastMoves.shift();
                }
                
                if (this.lastMoves.length === this.patternLength) {
                    const pattern = this.lastMoves.slice(0, -1).join('');
                    const nextMove = this.lastMoves[this.lastMoves.length - 1];
                    
                    if (!this.patterns[pattern]) {
                        this.patterns[pattern] = [0, 0, 0];
                    }
                    this.patterns[pattern][nextMove]++;
                }
            }
            
            predict() {
                if (this.lastMoves.length < this.patternLength - 1) return null;
                
                const currentPattern = this.lastMoves.slice(-(this.patternLength - 1)).join('');
                const probabilities = this.patterns[currentPattern];
                
                if (probabilities) {
                    const predictedMove = probabilities.indexOf(Math.max(...probabilities));
                    return (predictedMove + 1) % 3;
                }
                return null;
            }
        }
        
        // 3. Psychological Strategy
        class PsychologicalStrategy {
            constructor() {
                this.consecutiveCount = 0;
                this.lastMove = null;
            }
            
            update(move) {
                if (move === this.lastMove) {
                    this.consecutiveCount++;
                } else {
                    this.consecutiveCount = 1;
                }
                this.lastMove = move;
            }
            
            predict() {
                if (this.consecutiveCount >= 2) {
                    // If player repeats moves, they'll likely switch to beat their own move
                    return (this.lastMove + 1) % 3;
                }
                return null;
            }
        }

        // ======================
        // Python AI (via Pyodide)
        // ======================
        async function initializePythonAI() {
            try {
                // Load Pyodide
                game.pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.23.4/full/"
                });
                
                // Load numpy for advanced analysis
                await game.pyodide.loadPackage("numpy");
                
                // Initialize Python AI
                await game.pyodide.runPython(`
                    import numpy as np
                    from collections import defaultdict
                    
                    class AdvancedAI:
                        def __init__(self):
                            self.history = []
                            self.transition_counts = defaultdict(lambda: defaultdict(int))
                            self.move_counts = [0, 0, 0]
                            self.last_move = None
                            self.consecutive_count = 0
                        
                        def update(self, move):
                            self.move_counts[move] += 1
                            
                            if len(self.history) >= 2:
                                prev1, prev2 = self.history[-1], self.history[-2]
                                self.transition_counts[(prev2, prev1)][move] += 1
                            
                            if move == self.last_move:
                                self.consecutive_count += 1
                            else:
                                self.consecutive_count = 1
                            
                            self.last_move = move
                            self.history.append(move)
                            
                            if len(self.history) > 100:
                                self.history.pop(0)
                        
                        def predict(self):
                            # If player repeats, counter the expected change
                            if self.consecutive_count >= 2:
                                return (self.last_move + 1) % 3
                            
                            # Markov chain prediction
                            if len(self.history) >= 2:
                                prev1, prev2 = self.history[-1], self.history[-2]
                                transitions = self.transition_counts.get((prev2, prev1), {})
                                
                                if transitions:
                                    predicted = max(transitions.items(), key=lambda x: x[1])[0]
                                    confidence = transitions[predicted] / sum(transitions.values())
                                    
                                    if confidence > 0.6:
                                        return (predicted + 1) % 3
                            
                            # Fallback to frequency analysis
                            least_used = np.argmin(self.move_counts)
                            return (least_used + 1) % 3
                    
                    python_ai = AdvancedAI()
                `);
                
                return true;
            } catch (error) {
                console.error("Python AI failed to load:", error);
                return false;
            }
        }

        // ======================
        // Game Initialization
        // ======================
        async function initializeGame() {
            // Update loading progress
            document.getElementById('load-progress').style.width = '30%';
            
            // Initialize JavaScript strategies
            game.strategies = [
                new FrequencyStrategy(),
                new PatternStrategy(),
                new PsychologicalStrategy()
            ];
            
            document.getElementById('load-progress').style.width = '60%';
            
            // Initialize Python AI
            const pythonLoaded = await initializePythonAI();
            if (pythonLoaded) {
                game.pythonAI = true;
            }
            
            document.getElementById('load-progress').style.width = '100%';
            
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('game').style.display = 'block';
            }, 500);
        }

        // ======================
        // Game Logic
        // ======================
        async function play(move) {
            // Disable inputs during AI processing
            document.querySelectorAll('.choice').forEach(c => {
                c.style.pointerEvents = 'none';
                c.style.opacity = '0.7';
            });
            
            document.getElementById('ai-thinking').style.display = 'block';
            document.getElementById('ai-progress').style.width = '0%';
            
            // Simulate AI thinking with progress
            const progressInterval = setInterval(() => {
                const progress = document.getElementById('ai-progress');
                const width = parseInt(progress.style.width) || 0;
                if (width < 90) {
                    progress.style.width = (width + 10) + '%';
                }
            }, 200);
            
            // Update all strategies with the player's move
            game.strategies.forEach(strategy => strategy.update(move));
            if (game.pythonAI) {
                await game.pyodide.runPython(`python_ai.update(${move})`);
            }
            
            // Get predictions from all strategies
            const predictions = [];
            
            // Get JavaScript strategy predictions
            game.strategies.forEach(strategy => {
                const prediction = strategy.predict();
                if (prediction !== null) {
                    predictions.push(prediction);
                }
            });
            
            // Get Python AI prediction if available
            if (game.pythonAI) {
                const pythonPrediction = await game.pyodide.runPython(`python_ai.predict()`);
                predictions.push(pythonPrediction);
            }
            
            // Determine final AI move (weighted towards more sophisticated strategies)
            let aiMove;
            if (predictions.length > 0) {
                // Weight later strategies (more sophisticated) higher
                const weightedPredictions = [];
                predictions.forEach((pred, i) => {
                    // More weight to later strategies (index 0 is frequency, last is Python)
                    const weight = i + 1;
                    for (let j = 0; j < weight; j++) {
                        weightedPredictions.push(pred);
                    }
                });
                
                // Random selection from weighted predictions
                aiMove = weightedPredictions[Math.floor(Math.random() * weightedPredictions.length)];
            } else {
                // Fallback to random if no predictions
                aiMove = Math.floor(Math.random() * 3);
            }
            
            // Complete progress bar
            clearInterval(progressInterval);
            document.getElementById('ai-progress').style.width = '100%';
            
            // Process the result
            setTimeout(() => {
                processResult(move, aiMove);
                document.getElementById('ai-thinking').style.display = 'none';
                
                // Re-enable inputs
                document.querySelectorAll('.choice').forEach(c => {
                    c.style.pointerEvents = 'auto';
                    c.style.opacity = '1';
                });
            }, 300);
        }
        
        function processResult(playerMove, aiMove) {
            game.games++;
            game.history.push({player: playerMove, ai: aiMove});
            
            // Update UI
            document.getElementById('games').textContent = game.games;
            
            if (playerMove === aiMove) {
                game.draws++;
                document.getElementById('draws').textContent = game.draws;
                document.getElementById('result').innerHTML = `
                    <div style="font-size: 2rem">${game.moveNames[playerMove]} vs ${game.moveNames[aiMove]}</div>
                    <div style="color: #666; font-size: 1.5rem">Draw!</div>
                `;
            } 
            else if ((playerMove + 1) % 3 === aiMove) {
                game.aiWins++;
                document.getElementById('ai-wins').textContent = game.aiWins;
                document.getElementById('result').innerHTML = `
                    <div style="font-size: 2rem">${game.moveNames[playerMove]} vs ${game.moveNames[aiMove]}</div>
                    <div style="color: #e74c3c; font-size: 1.5rem">AI wins!</div>
                `;
            } 
            else {
                game.wins++;
                document.getElementById('wins').textContent = game.wins;
                document.getElementById('result').innerHTML = `
                    <div style="font-size: 2rem">${game.moveNames[playerMove]} vs ${game.moveNames[aiMove]}</div>
                    <div style="color: #2ecc71; font-size: 1.5rem">You win!</div>
                `;
            }
            
            // Update win rate
            const winRate = game.games > 0 ? Math.round((game.wins / game.games) * 100) : 0;
            document.getElementById('win-rate').textContent = winRate;
        }

        // Initialize
        document.querySelectorAll('.choice').forEach(choice => {
            choice.addEventListener('click', (e) => {
                play(parseInt(e.target.getAttribute('data-move')));
            });
        });

        // Start the game
        initializeGame();
    </script>
    <!-- Load Pyodide runtime -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
</body>
</html>
