<!DOCTYPE html>
<html>
<head>
    <title>RPS AI with Global Learning</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        .choices button {
            font-size: 50px;
            width: 80px;
            height: 80px;
            border: none;
            background: #4285f4;
            color: white;
            border-radius: 50%;
            cursor: pointer;
            margin: 10px;
        }
        #result {
            font-size: 24px;
            margin: 20px 0;
            min-height: 60px;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
        }
        .stat-box {
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
        }
        .win { color: green; }
        .lose { color: red; }
        .draw { color: orange; }
        #global-data {
            margin-top: 20px;
            padding: 15px;
            background: #e8f4f8;
            border-radius: 5px;
        }
        #loading {
            margin: 30px 0;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <h1>Rock Paper Scissors AI</h1>
    <p>Global Learning Edition</p>

    <div id="loading">Initializing AI...</div>
    
    <div id="game" style="display:none;">
        <div class="choices">
            <button id="rock">✊</button>
            <button id="paper">✋</button>
            <button id="scissors">✌️</button>
        </div>
        
        <div id="result">Make your move!</div>
        
        <div class="stats">
            <div class="stat-box">
                <h3>You</h3>
                <p>Wins: <span id="user-wins">0</span></p>
                <p>Losses: <span id="user-losses">0</span></p>
            </div>
            <div class="stat-box">
                <h3>AI</h3>
                <p>Win Rate: <span id="ai-win-rate">0%</span></p>
                <p>Games: <span id="total-games">0</span></p>
            </div>
        </div>
        
        <div id="global-data">
            <h3>Global Model</h3>
            <p>Training Cycles: <span id="global-cycles">0</span></p>
            <p>Total Contributors: <span id="contributors">0</span></p>
            <p>Total Games Trained: <span id="global-games">0</span></p>
        </div>
    </div>

    <script>
        // Configuration - replace with your Supabase credentials
        const SUPABASE_URL = 'https://orpljgijsehehkbnfqpk.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9ycGxqZ2lqc2VoZWhrYm5mcXBrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEyMTkzMTIsImV4cCI6MjA1Njc5NTMxMn0.QcdyYLwNlOGwN6yi67Sm6oEEX86AOtudP24yVlodpKg';
        const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        
        // Game state
        const game = {
            userWins: 0,
            userLosses: 0,
            draws: 0,
            model: null,
            ready: false,
            trainingData: [],
            globalStats: {
                trainingCycles: 0,
                contributors: 0,
                totalGames: 0
            }
        };
        
        // Initialize game
        async function init() {
            try {
                // Create a simple model
                game.model = createModel();
                
                // Load global model from Supabase
                await loadGlobalModel();
                
                // Setup event listeners
                document.getElementById('rock').onclick = () => playRound('rock');
                document.getElementById('paper').onclick = () => playRound('paper');
                document.getElementById('scissors').onclick = () => playRound('scissors');
                
                // Show game UI
                document.getElementById('loading').style.display = 'none';
                document.getElementById('game').style.display = 'block';
                game.ready = true;
                
                console.log("AI ready!");
            } catch (error) {
                document.getElementById('loading').textContent = 'Error loading AI. Please refresh.';
                console.error("Initialization error:", error);
            }
        }
        
        // Create a simple neural network
        function createModel() {
            const model = tf.sequential();
            model.add(tf.layers.dense({
                units: 8,
                activation: 'relu',
                inputShape: [6] // Last 2 moves from player and AI
            }));
            model.add(tf.layers.dense({
                units: 3, // Output: rock, paper, scissors
                activation: 'softmax'
            }));
            model.compile({
                optimizer: 'adam',
                loss: 'categoricalCrossentropy'
            });
            return model;
        }
        
        // Play a round
        async function playRound(playerMove) {
            if (!game.ready) return;
            
            // Get AI move
            const aiMove = await getAiMove(playerMove);
            
            // Determine result
            const result = getResult(playerMove, aiMove);
            
            // Update game state
            updateGameState(playerMove, aiMove, result);
            
            // Add to training data
            game.trainingData.push({
                input: prepareInput(playerMove),
                output: oneHotEncode(getCounterMove(playerMove))
            });
            
            // Train periodically
            if (game.trainingData.length >= 5) {
                await trainModel();
                game.trainingData = []; // Clear training data
            }
        }
        
        // Get AI move
        async function getAiMove(playerMove) {
            const moves = ['rock', 'paper', 'scissors'];
            
            // First few moves are random
            if (game.userWins + game.userLosses < 3) {
                return moves[Math.floor(Math.random() * 3)];
            }
            
            try {
                // Prepare input
                const input = prepareInput(playerMove);
                const tensor = tf.tensor2d([input]);
                
                // Get prediction
                const prediction = await game.model.predict(tensor).array();
                tensor.dispose();
                
                // Choose move (with some randomness)
                if (Math.random() < 0.1) {
                    return moves[Math.floor(Math.random() * 3)]; // 10% random exploration
                }
                
                return moves[prediction[0].indexOf(Math.max(...prediction[0]))];
            } catch (error) {
                console.error("Prediction error:", error);
                return moves[Math.floor(Math.random() * 3)]; // Fallback to random
            }
        }
        
        // Prepare input for the neural network
        function prepareInput(playerMove) {
            // Use last 2 moves as context
            const history = game.trainingData.slice(-2);
            const input = [];
            
            // Add history (pad with zeros if not enough history)
            history.forEach(item => {
                input.push(...item.input.slice(0, 3)); // Player move
                input.push(...item.input.slice(3, 6)); // AI move
            });
            
            // Pad if not enough history
            while (input.length < 6) input.push(0);
            
            return input;
        }
        
        // One-hot encode moves
        function oneHotEncode(move) {
            return [
                move === 'rock' ? 1 : 0,
                move === 'paper' ? 1 : 0,
                move === 'scissors' ? 1 : 0
            ];
        }
        
        // Determine game result
        function getResult(player, ai) {
            if (player === ai) return 'draw';
            if ((player === 'rock' && ai === 'scissors') ||
                (player === 'paper' && ai === 'rock') ||
                (player === 'scissors' && ai === 'paper')) return 'win';
            return 'lose';
        }
        
        // Get counter move
        function getCounterMove(move) {
            return {
                rock: 'paper',
                paper: 'scissors',
                scissors: 'rock'
            }[move];
        }
        
        // Update game state and UI
        function updateGameState(playerMove, aiMove, result) {
            if (result === 'win') game.userWins++;
            if (result === 'lose') game.userLosses++;
            if (result === 'draw') game.draws++;
            
            // Update UI
            document.getElementById('user-wins').textContent = game.userWins;
            document.getElementById('user-losses').textContent = game.userLosses;
            
            const totalGames = game.userWins + game.userLosses;
            const winRate = totalGames > 0 ? Math.round((game.userLosses / totalGames) * 100) : 0;
            document.getElementById('ai-win-rate').textContent = `${winRate}%`;
            document.getElementById('total-games').textContent = game.userWins + game.userLosses + game.draws;
            
            // Show result
            document.getElementById('result').innerHTML = `
                You played <strong>${playerMove}</strong><br>
                AI played <strong>${aiMove}</strong><br>
                <span class="${result}">${result.toUpperCase()}!</span>
            `;
        }
        
        // Train the model
        async function trainModel() {
            try {
                // Prepare training data
                const inputs = game.trainingData.map(item => item.input);
                const labels = game.trainingData.map(item => item.output);
                
                // Train locally
                await game.model.fit(
                    tf.tensor2d(inputs),
                    tf.tensor2d(labels),
                    {
                        epochs: 3,
                        batchSize: 2,
                        verbose: 0
                    }
                );
                
                // Update global stats
                game.globalStats.trainingCycles++;
                game.globalStats.totalGames += game.trainingData.length;
                
                // Sync with Supabase every 5 training cycles
                if (game.globalStats.trainingCycles % 5 === 0) {
                    await syncGlobalModel();
                }
                
                // Update UI
                updateGlobalStats();
                
            } catch (error) {
                console.error("Training error:", error);
            }
        }
        
        // Load global model from Supabase
        async function loadGlobalModel() {
            try {
                const { data, error } = await supabase
                    .from('global_models')
                    .select('model_data, training_cycles, contributors, total_games')
                    .eq('name', 'rps_global')
                    .single();
                
                if (data && data.model_data) {
                    // Load model artifacts
                    const artifacts = JSON.parse(atob(data.model_data));
                    await game.model.load(artifacts);
                    
                    // Update global stats
                    game.globalStats = {
                        trainingCycles: data.training_cycles || 0,
                        contributors: data.contributors || 0,
                        totalGames: data.total_games || 0
                    };
                    
                    updateGlobalStats();
                    console.log("Loaded global model");
                }
            } catch (error) {
                console.log("No global model found, starting fresh");
            }
        }
        
        // Sync model with Supabase
        async function syncGlobalModel() {
            try {
                // Get model artifacts
                const artifacts = await game.model.save();
                const modelData = btoa(JSON.stringify(artifacts));
                
                // Update global stats
                game.globalStats.contributors += 1;
                
                // Upsert to Supabase
                const { error } = await supabase
                    .from('global_models')
                    .upsert({
                        name: 'rps_global',
                        model_data: modelData,
                        training_cycles: game.globalStats.trainingCycles,
                        contributors: game.globalStats.contributors,
                        total_games: game.globalStats.totalGames,
                        updated_at: new Date().toISOString()
                    });
                
                if (!error) {
                    console.log("Model synced with Supabase");
                }
            } catch (error) {
                console.error("Error syncing model:", error);
            }
        }
        
        // Update global stats display
        function updateGlobalStats() {
            document.getElementById('global-cycles').textContent = game.globalStats.trainingCycles;
            document.getElementById('contributors').textContent = game.globalStats.contributors;
            document.getElementById('global-games').textContent = game.globalStats.totalGames;
        }
        
        // Start the game
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
