<!DOCTYPE html
<html>
<head>
    <title>Neural RPS Master</title>
    <style>
        :root {
            --primary: #4285f4;
            --danger: #ea4335;
            --success: #34a853;
            --warning: #fbbc05;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            color: #2d3748;
        }
        .choices {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin: 40px 0;
            flex-wrap: wrap;
        }
        .choice {
            font-size: 80px;
            cursor: pointer;
            padding: 25px;
            border-radius: 50%;
            background: white;
            box-shadow: 0 8px 15px rgba(0,0,0,0.1);
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .choice:hover {
            transform: scale(1.15) rotate(5deg);
            box-shadow: 0 12px 20px rgba(0,0,0,0.15);
        }
        .choice::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .choice:hover::after {
            opacity: 1;
        }
        #result {
            font-size: 28px;
            margin: 40px 0;
            padding: 30px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            min-height: 150px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 40px 0;
        }
        .stat {
            padding: 20px;
            border-radius: 12px;
            background: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.08);
            font-weight: 500;
        }
        #loading {
            margin: 40px 0;
            font-size: 22px;
        }
        #ai-thinking {
            display: none;
            margin: 30px 0;
            font-size: 20px;
        }
        .progress-container {
            width: 100%;
            max-width: 400px;
            margin: 20px auto;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--warning) 100%);
            width: 0%;
            transition: width 0.4s ease;
        }
        .move-history {
            margin-top: 40px;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.08);
        }
        .history-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
        }
        .history-item:last-child {
            border-bottom: none;
        }
        .win {
            color: var(--success);
            font-weight: bold;
        }
        .lose {
            color: var(--danger);
            font-weight: bold;
        }
        .draw {
            color: #666;
            font-weight: bold;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .pulse {
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <h1>Neural RPS Master</h1>
    <p>Advanced AI combining deep learning with human psychology models</p>
    
    <div id="loading" class="pulse">
        <div>Initializing neural networks...</div>
        <div class="progress-container">
            <div class="progress-bar" id="load-progress"></div>
        </div>
    </div>
    
    <div id="game" style="display:none">
        <div class="choices">
            <div class="choice" data-move="0">✊</div>
            <div class="choice" data-move="1">✋</div>
            <div class="choice" data-move="2">✌️</div>
        </div>
        
        <div id="ai-thinking">
            <div>Analyzing micro-patterns in your gameplay...</div>
            <div class="progress-container">
                <div class="progress-bar" id="ai-progress"></div>
            </div>
        </div>
        
        <div id="result">Make your move to begin!</div>
        
        <div class="stats">
            <div class="stat">Total Games: <span id="games">0</span></div>
            <div class="stat">Your Wins: <span id="wins">0</span></div>
            <div class="stat">AI Wins: <span id="ai-wins">0</span></div>
            <div class="stat">Draws: <span id="draws">0</span></div>
            <div class="stat">Win Rate: <span id="win-rate">0</span>%</div>
        </div>
        
        <div class="move-history">
            <h3>Game History</h3>
            <div id="history"></div>
        </div>
    </div>

    <script>
        // ===========================================
        // Enhanced Game Engine with Human Psychology
        // ===========================================
        
        // Game state with enhanced tracking
        const game = {
            history: [],
            games: 0,
            wins: 0,
            aiWins: 0,
            draws: 0,
            moveNames: ['Rock ✊', 'Paper ✋', 'Scissors ✌️'],
            strategies: [],
            timingData: [],
            reactionTimes: [],
            moveFrequencies: [0, 0, 0],
            transitionMatrix: Array(3).fill().map(() => Array(3).fill().map(() => Array(3).fill(0))),
            streakData: { current: 0, lastMove: null },
            pyodide: null,
            lastMoveTime: null,
            sessionStart: Date.now()
        };

        // ===========================================
        // JavaScript AI Strategies
        // ===========================================
        
        // 1. Enhanced Frequency Analysis with Decay
        class FrequencyStrategy {
            constructor() {
                this.moveCounts = [1, 1, 1]; // Start with pseudocounts
                this.decayRate = 0.95; // Older moves matter less
            }
            
            update(move) {
                // Apply decay to all counts
                this.moveCounts = this.moveCounts.map(c => c * this.decayRate);
                this.moveCounts[move] += 1;
            }
            
            predict() {
                // Find least used move recently and counter it
                const leastUsed = this.moveCounts.indexOf(Math.min(...this.moveCounts));
                return (leastUsed + 1) % 3;
            }
        }
        
        // 2. Advanced Pattern Recognition with Variable Length
        class PatternStrategy {
            constructor() {
                this.patterns = {};
                this.maxPatternLength = 5;
                this.minPatternLength = 2;
            }
            
            update(move) {
                // Update patterns of all lengths
                for (let len = this.minPatternLength; len <= Math.min(this.maxPatternLength, game.history.length); len++) {
                    const pattern = game.history.slice(-len).map(m => m.player).join('');
                    if (!this.patterns[pattern]) {
                        this.patterns[pattern] = [0, 0, 0];
                    }
                    this.patterns[pattern][move]++;
                }
            }
            
            predict() {
                // Try patterns from longest to shortest
                for (let len = Math.min(this.maxPatternLength, game.history.length); len >= this.minPatternLength; len--) {
                    const recentPattern = game.history.slice(-len).map(m => m.player).join('');
                    const probabilities = this.patterns[recentPattern];
                    
                    if (probabilities && Math.max(...probabilities) > 3) { // Minimum 3 occurrences
                        const predictedMove = probabilities.indexOf(Math.max(...probabilities));
                        return (predictedMove + 1) % 3;
                    }
                }
                return null;
            }
        }
        
        // 3. Psychological Strategy with Streak Detection
        class PsychologicalStrategy {
            constructor() {
                this.consecutiveCount = 0;
                this.lastMove = null;
                this.antiPatternCount = 0;
            }
            
            update(move) {
                if (move === this.lastMove) {
                    this.consecutiveCount++;
                    // Humans often change after 2-3 repeats
                    if (this.consecutiveCount >= 2) {
                        this.antiPatternCount++;
                    }
                } else {
                    this.consecutiveCount = 1;
                }
                this.lastMove = move;
            }
            
            predict() {
                // If player is repeating, predict they'll switch to beat their own move
                if (this.consecutiveCount >= 2) {
                    return (this.lastMove + 1) % 3;
                }
                
                // If player just broke a streak, they may be starting a new pattern
                if (this.consecutiveCount === 1 && this.antiPatternCount > 2) {
                    return this.lastMove; // Play what would tie their last move
                }
                
                return null;
            }
        }

        // 4. Timing Analysis Strategy
        class TimingStrategy {
            constructor() {
                this.moveTimings = [[], [], []]; // Arrays of timings for each move
                this.lastMoveTime = null;
            }
            
            update(move, timeSinceLastMove) {
                if (timeSinceLastMove !== null) {
                    this.moveTimings[move].push(timeSinceLastMove);
                    // Keep only recent data
                    if (this.moveTimings[move].length > 20) {
                        this.moveTimings[move].shift();
                    }
                }
                this.lastMoveTime = Date.now();
            }
            
            predict() {
                // If player is taking longer than average, they're likely to switch
                const currentTime = Date.now();
                const timeSinceLast = this.lastMoveTime ? (currentTime - this.lastMoveTime) : null;
                
                if (timeSinceLast && game.history.length > 5) {
                    const lastMove = game.history[game.history.length - 1].player;
                    const avgTime = this.moveTimings[lastMove].length > 0 ?
                        this.moveTimings[lastMove].reduce((a, b) => a + b, 0) / this.moveTimings[lastMove].length :
                        null;
                    
                    if (avgTime && timeSinceLast > avgTime * 1.3) {
                        return (lastMove + 2) % 3; // Play what would lose to their last move (they're likely to switch)
                    }
                }
                return null;
            }
        }

        // ===========================================
        // Python AI (via Pyodide) - Advanced Analytics
        // ===========================================
        async function initializePythonAI() {
            try {
                // Show loading progress
                updateLoadProgress(10);
                
                // Load Pyodide
                game.pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.23.4/full/"
                });
                updateLoadProgress(30);
                
                // Load required packages
                await game.pyodide.loadPackage("numpy");
                updateLoadProgress(50);
                await game.pyodide.loadPackage("scipy");
                updateLoadProgress(70);
                
                // Initialize Python AI with enhanced models
                await game.pyodide.runPython(`
                    import numpy as np
                    from collections import defaultdict, Counter
                    from scipy.stats import mode
                    
                    class NeuralPredictor:
                        def __init__(self):
                            self.history = []
                            self.transition_probs = np.ones((3, 3, 3)) / 3  # Start with uniform probabilities
                            self.move_frequencies = np.ones(3)
                            self.consecutive_counts = [0, 0, 0]
                            self.last_move = None
                            self.session_duration = 0
                            self.learning_rate = 0.1
                        
                        def update(self, move):
                            # Update frequencies with exponential decay
                            self.move_frequencies = self.move_frequencies * 0.95
                            self.move_frequencies[move] += 1
                            
                            # Update transition probabilities
                            if len(self.history) >= 2:
                                prev1, prev2 = self.history[-1], self.history[-2]
                                self.transition_probs[prev2][prev1][move] += 1
                            
                            # Update consecutive counts
                            if move == self.last_move:
                                self.consecutive_counts[move] += 1
                            else:
                                self.consecutive_counts = [0, 0, 0]
                                self.consecutive_counts[move] = 1
                            
                            self.last_move = move
                            self.history.append(move)
                            
                            # Keep history manageable
                            if len(self.history) > 100:
                                self.history.pop(0)
                            
                            # Adjust learning rate based on session duration
                            self.session_duration += 1
                            self.learning_rate = max(0.01, 0.2 - (self.session_duration / 1000))
                        
                        def predict(self):
                            # If player repeats, use sophisticated anti-pattern detection
                            if self.last_move is not None and self.consecutive_counts[self.last_move] >= 2:
                                if np.random.random() < 0.8:  # 80% confidence in anti-pattern
                                    return (self.last_move + 1) % 3
                            
                            # Use Markov chain with confidence threshold
                            if len(self.history) >= 2:
                                prev1, prev2 = self.history[-1], self.history[-2]
                                probs = self.transition_probs[prev2][prev1]
                                predicted = np.argmax(probs)
                                confidence = probs[predicted] / np.sum(probs)
                                
                                if confidence > 0.65:  # Only use if confident
                                    return (predicted + 1) % 3
                            
                            # Fallback to frequency analysis with noise
                            noise = np.random.normal(0, 0.1, 3)
                            adjusted_freq = self.move_frequencies + noise
                            least_used = np.argmin(adjusted_freq)
                            return (least_used + 1) % 3
                    
                    python_ai = NeuralPredictor()
                `);
                updateLoadProgress(90);
                
                return true;
            } catch (error) {
                console.error("Python AI failed to load:", error);
                return false;
            }
        }

        // ===========================================
        // Game Initialization
        // ===========================================
        function updateLoadProgress(percent) {
            document.getElementById('load-progress').style.width = `${percent}%`;
        }
        
        async function initializeGame() {
            // Initialize JavaScript strategies
            game.strategies = [
                new FrequencyStrategy(),
                new PatternStrategy(),
                new PsychologicalStrategy(),
                new TimingStrategy()
            ];
            
            // Initialize Python AI
            game.pythonAI = await initializePythonAI();
            
            // Complete loading
            updateLoadProgress(100);
            
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('game').style.display = 'block';
            }, 500);
            
            // Start tracking session time
            game.sessionStart = Date.now();
        }

        // ===========================================
        // Game Logic with Enhanced AI Decision Making
        // ===========================================
        async function play(move) {
            // Calculate time since last move
            const now = Date.now();
            const timeSinceLast = game.lastMoveTime ? now - game.lastMoveTime : null;
            game.lastMoveTime = now;
            
            // Disable inputs during processing
            disableChoices(true);
            document.getElementById('ai-thinking').style.display = 'block';
            
            // Simulate AI processing with progress
            const progressInterval = simulateAIThinking();
            
            // Update all strategies
            updateStrategies(move, timeSinceLast);
            
            // Get predictions from all strategies
            const predictions = await collectPredictions();
            
            // Determine final AI move
            const aiMove = determineAIMove(predictions);
            
            // Complete processing
            clearInterval(progressInterval);
            document.getElementById('ai-progress').style.width = '100%';
            
            // Process and display result
            setTimeout(() => {
                processResult(move, aiMove);
                document.getElementById('ai-thinking').style.display = 'none';
                disableChoices(false);
            }, 300);
        }
        
        function simulateAIThinking() {
            let progress = 0;
            return setInterval(() => {
                progress = Math.min(progress + Math.random() * 10, 90);
                document.getElementById('ai-progress').style.width = `${progress}%`;
            }, 200);
        }
        
        function updateStrategies(move, timeSinceLast) {
            // Update JavaScript strategies
            game.strategies.forEach(strategy => {
                strategy.update(move);
                if (strategy instanceof TimingStrategy && timeSinceLast !== null) {
                    strategy.update(move, timeSinceLast);
                }
            });
            
            // Update Python AI if available
            if (game.pythonAI) {
                game.pyodide.runPython(`python_ai.update(${move})`);
            }
            
            // Update game-level tracking
            game.moveFrequencies[move]++;
            if (game.history.length > 0) {
                const lastMove = game.history[game.history.length - 1].player;
                game.transitionMatrix[lastMove][move][move]++;
            }
        }
        
        async function collectPredictions() {
            const predictions = [];
            
            // Get JavaScript strategy predictions
            game.strategies.forEach(strategy => {
                const prediction = strategy.predict();
                if (prediction !== null) {
                    predictions.push({
                        move: prediction,
                        weight: strategy instanceof TimingStrategy ? 1.5 : 1 // Weight timing slightly higher
                    });
                }
            });
            
            // Get Python AI prediction if available
            if (game.pythonAI) {
                const pythonPrediction = await game.pyodide.runPython(`python_ai.predict()`);
                predictions.push({
                    move: pythonPrediction,
                    weight: 2.5 // Highest weight for Python AI
                });
            }
            
            return predictions;
        }
        
        function determineAIMove(predictions) {
            if (predictions.length === 0) {
                return Math.floor(Math.random() * 3); // Fallback
            }
            
            // Create weighted predictions array
            const weightedPredictions = [];
            predictions.forEach(pred => {
                for (let i = 0; i < pred.weight * 10; i++) {
                    weightedPredictions.push(pred.move);
                }
            });
            
            // Select randomly from weighted options
            return weightedPredictions[Math.floor(Math.random() * weightedPredictions.length)];
        }
        
        function disableChoices(disabled) {
            document.querySelectorAll('.choice').forEach(choice => {
                choice.style.pointerEvents = disabled ? 'none' : 'auto';
                choice.style.opacity = disabled ? '0.6' : '1';
                choice.style.transform = disabled ? 'scale(0.95)' : 'scale(1)';
            });
        }
        
        function processResult(playerMove, aiMove) {
            game.games++;
            const result = {
                player: playerMove,
                ai: aiMove,
                time: Date.now(),
                result: null
            };
            
            if (playerMove === aiMove) {
                game.draws++;
                result.result = 'draw';
                document.getElementById('result').innerHTML = `
                    <div style="font-size: 2.2rem">${game.moveNames[playerMove]} vs ${game.moveNames[aiMove]}</div>
                    <div style="color: #666; font-size: 1.8rem; margin-top: 10px">Draw!</div>
                `;
            } 
            else if ((playerMove + 1) % 3 === aiMove) {
                game.aiWins++;
                result.result = 'ai-win';
                document.getElementById('result').innerHTML = `
                    <div style="font-size: 2.2rem">${game.moveNames[playerMove]} vs ${game.moveNames[aiMove]}</div>
                    <div style="color: var(--danger); font-size: 1.8rem; margin-top: 10px">AI wins!</div>
                `;
            } 
            else {
                game.wins++;
                result.result = 'player-win';
                document.getElementById('result').innerHTML = `
                    <div style="font-size: 2.2rem">${game.moveNames[playerMove]} vs ${game.moveNames[aiMove]}</div>
                    <div style="color: var(--success); font-size: 1.8rem; margin-top: 10px">You win!</div>
                `;
            }
            
            game.history.push(result);
            
            // Update UI
            updateStats();
            updateHistory(result);
        }
        
        function updateStats() {
            document.getElementById('games').textContent = game.games;
            document.getElementById('wins').textContent = game.wins;
            document.getElementById('ai-wins').textContent = game.aiWins;
            document.getElementById('draws').textContent = game.draws;
            
            const winRate = game.games > 0 ? Math.round((game.wins / game.games) * 100) : 0;
            document.getElementById('win-rate').textContent = winRate;
        }
        
        function updateHistory(result) {
            const historyEl = document.getElementById('history');
            const item = document.createElement('div');
            item.className = 'history-item';
            
            let resultText, resultClass;
            if (result.result === 'draw') {
                resultText = 'Draw';
                resultClass = 'draw';
            } else if (result.result === 'ai-win') {
                resultText = 'AI Won';
                resultClass = 'lose';
            } else {
                resultText = 'You Won';
                resultClass = 'win';
            }
            
            item.innerHTML = `
                <span>${game.moveNames[result.player]} vs ${game.moveNames[result.ai]}</span>
                <span class="${resultClass}">${resultText}</span>
            `;
            
            historyEl.prepend(item);
            
            // Keep history manageable
            if (historyEl.children.length > 10) {
                historyEl.removeChild(historyEl.lastChild);
            }
        }

        // Initialize
        document.querySelectorAll('.choice').forEach(choice => {
            choice.addEventListener('click', (e) => {
                if (!document.getElementById('ai-thinking').style.display || 
                    document.getElementById('ai-thinking').style.display === 'none') {
                    play(parseInt(e.target.getAttribute('data-move')));
                }
            });
        });

        // Start the game
        initializeGame();
    </script>
    <!-- Load Pyodide runtime -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js"></script>
</body>
</html>
